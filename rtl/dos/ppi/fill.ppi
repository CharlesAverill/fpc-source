{
    $Id$
    This file is part of the Free Pascal run time library.
    Copyright (c) 1993,97 by the Free Pascal development team.

    See the file COPYING.FPC, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 **********************************************************************}

{$ifopt S+}
{$define StackCkeckOn}
{$endif opt S+}

procedure floodfill(x,y:integer; border:longint);

var bordercol     : longint;
    fillcol,fillbkcol : longint;
    viewport      : viewporttype;
    offset        : longint;
    test_bkfill   : boolean;

{$S+}
{ Fill is very recursive !! }
{ And it fails sometimes !! }

procedure fill(x,y:integer);
var start,ende,xx : integer;
    col           : longint;
 
begin  
{$ifdef ExtDebug}
     Writeln(stderr,'Fill ',x,' ',y);
{$endif def ExtDebug}
  xx:=x; col:=getpixel(xx,y);
{$ifdef ExtDebug}
     Writeln(stderr,'Fill ',x,' ',y,' ',col);
{$endif def ExtDebug}
  if (col=bordercol) or (col=fillcol) or (test_bkfill and (col=fillbkcol)) then exit;
  while (col<>bordercol) and (xx > viewport.x1) and
     (col<>fillcol) and (not test_bkfill or (col<>fillbkcol))
    do begin
      xx:=xx-1; col:=getpixel(xx,y);
    end;
  if (col<>bordercol) and (col<>fillcol) and
     (not test_bkfill or (col<>fillbkcol)) then
    start:=xx
  else
    start:=xx+1;

  xx:=x+1; col:=getpixel(xx,y);
  while (col<>bordercol) and (xx < viewport.x2) and (col<>fillcol)
      and (not test_bkfill or (col<>fillbkcol)) 
    do begin
      xx:=xx+1; col:=getpixel(xx,y);
    end;
  if (col<>bordercol) and (col<>fillcol) and
     (not test_bkfill or (col<>fillbkcol)) then
    ende:=xx
  else
    ende:=xx-1;

{$ifdef ExtDebug}
     Writeln(stderr,'Pattern ',start,' ',ende,' ',y);
{$endif def ExtDebug}
  patternline(start,ende,y);
{$ifdef ExtDebug}
     Writeln(stderr,'Fill  after Patterline ',x,' ',y,' ',getpixel(x,y));
{$endif def ExtDebug}
  offset:=(y * _maxy + start) shr 8;
  
  if (y > viewport.y1)
  then begin
    xx:=start;
    repeat
      col:=getpixel(xx,y-1);
      if (col<>bordercol) and (col<>fillcol) and
         (not test_bkfill or (col<>fillbkcol)) 
      then begin
        fill(xx,y-1);
        break;
      end;
      xx:=xx+1;
    until xx > ende;
  end;

  if (y >= viewport.y1) and (y<viewport.y2) then
   begin
    xx:=start;
    repeat
      col:=getpixel(xx,y+1);
      if (col<>bordercol) and (col<>fillcol) and
         (not test_bkfill or (col<>fillbkcol)) then
        fill(xx,y+1);
      xx:=xx+1;
    until xx > ende;
  end;

end;

begin
  fillchar(buffermem^,buffersize,0);
  if aktviewport.clip then viewport:=aktviewport else viewport:=aktscreen;
  viewport.x2:=viewport.x2-viewport.x1;
  viewport.y2:=viewport.y2-viewport.y1;
  viewport.x1:=0;
  viewport.y1:=0;
  bordercol:=convert(border);
  if BytesPerPixel=1
  then begin
    bordercol:=bordercol and $FF;
    fillcol:=aktfillsettings.color and $FF;
    fillbkCol:=aktfillbkcolor and $FF;
  end
{$ifdef TEST_24BPP}
  else if BytesPerPixel=3
  then begin
    bordercol:=bordercol and $FFFFFF;
    fillcol:=aktfillsettings.color and $FFFFFF;
    fillbkCol:=aktfillbkcolor and $FFFFFF;
  end
{$endif TEST_24BPP}
  else if BytesPerPixel=2
  then begin
    bordercol:=bordercol and $FFFF;
    fillcol:=aktfillsettings.color and $FFFF;
    fillbkCol:=aktfillbkcolor and $FFFF;
  end;
  
  if aktfillsettings.pattern=emptyfill then
    begin
       fillcol:=fillbkcol;
       test_bkfill:=false;
    end
  else if aktfillsettings.pattern=solidfill then
     test_bkfill:=false
  else
    test_bkfill:=true;
{$ifdef ExtDebug}
     Writeln(stderr,'Fillcol ',fillcol,' bordercol',bordercol);
{$endif def ExtDebug}
  fill(x,y);
end;

{$ifndef StackCkeckOn}
{$S-} { return to normal state }
{$else }
{$undef StackCheckOn}
{$endif }

procedure GetFillSettings(var Fillinfo:Fillsettingstype);
begin
  _graphresult:=grOk;
  if not isgraphmode then
    begin
      _graphresult:=grnoinitgraph;
      exit;
    end;
  Fillinfo:=aktfillsettings;
  Fillinfo.color:=unconvert(aktfillsettings.color);
end;

procedure GetFillPattern(var FillPattern:FillPatternType);
begin
  _graphresult:=grOk;
  if not isgraphmode then
    begin
      _graphresult:=grnoinitgraph;
      exit;
    end;
  FillPattern:=aktfillpattern;
end;

procedure SetFillPattern(pattern : FillPatternType;color : longint);
begin
  _graphresult:=grOk;
  if not isgraphmode then
    begin
      _graphresult:=grnoinitgraph;
      exit;
    end;
  fillpattern[12]:=pattern;
  SetFillStyle(12,color);
end;

procedure SetFillStyle(pattern : word ;color : longint);
var i,j:Integer;
    mask:Byte;
begin
  _graphresult:=grOk;
  if not isgraphmode then
    begin
      _graphresult:=grnoinitgraph;
      exit;
    end;
    { gÅltige Paramter ? }
  if (pattern<0) or (pattern>12) then
    begin
      _graphresult:=grError;
      exit;
    end;
    { Muster laden }
  aktfillpattern:=fillpattern[pattern];
  aktfillsettings.pattern:=pattern;
  aktfillsettings.color:=convert(color);
  aktfillbkcolor:=aktbackcolor;
  i:=1; j:=0;
  repeat
    mask:=$80;
      repeat
        if (aktfillpattern[i] and mask) = 0
          then PatternBuffer[j]:=aktbackcolor else PatternBuffer[j]:=aktfillsettings.color;
           mask:=mask shr 1;
           j:=j+1;
      until mask=0;
      i:=i+1;
  until i > 8;
end;

procedure GetLineSettings(var LineInfo : LineSettingsType);
begin
  _graphresult:=grOk;
  if not isgraphmode then
    begin
      _graphresult:=grnoinitgraph;
      exit;
    end;
  lineinfo:=aktlineinfo;
end;

{ just dummy not implemented yet }
procedure FillPoly(points : word;var polypoints);
{$R-}
 type PointTypeArray = Array[0..0] of PointType;
 var xm,ym : longint;
     i : word;
begin
   { simply call drawpoly instead (PM) }
   DrawPoly(points,polypoints);
   { assume the poly is convex so the barcenter is inside PM }
   { this can be completely wrong !! }
   xm:=0;
   ym:=0;
   For i:=0 to points-1 do
     begin
        xm:=xm+PointTypeArray(polypoints)[i].x;
        ym:=ym+PointTypeArray(polypoints)[i].y;
     end;
   xm:=xm div points;
   ym:=ym div points;
   floodfill(xm,ym,truecolor);
end;


{
  $Log$
  Revision 1.4  1998-11-19 09:48:48  pierre
    + added some functions missing like sector ellipse getarccoords
      (the filling of sector and ellipse is still buggy
       I use floodfill but sometimes the starting point
       is outside !!)
    * fixed a bug in floodfill for patterns
      (still has problems !!)

  Revision 1.3  1998/11/18 13:23:34  pierre
    * floodfill got into an infinite loop !!
    + added partial support for fillpoly
      (still wrong if the polygon is not convex)
      Simply make a floodfill from the barycenter !
    * some 24BPP code changed (still does not work for my S3VBE program !)

  Revision 1.2  1998/11/18 09:31:33  pierre
    * changed color scheme
      all colors are in RGB format if more than 256 colors
    + added 24 and 32 bits per pixel mode
      (compile with -dDEBUG)
      24 bit mode with banked still as problems on pixels across
      the bank boundary, but works in LinearFrameBufferMode
      Look at install/demo/nmandel.pp

  Revision 1.1.1.1  1998/03/25 11:18:42  root
  * Restored version

  Revision 1.3  1998/01/26 11:57:57  michael
  + Added log at the end


  
  Working file: rtl/dos/ppi/fill.ppi
  description:
  ----------------------------
  revision 1.2
  date: 1997/12/01 12:21:29;  author: michael;  state: Exp;  lines: +13 -1
  + added copyright reference in header.
  ----------------------------
  revision 1.1
  date: 1997/11/27 08:33:51;  author: michael;  state: Exp;
  Initial revision
  ----------------------------
  revision 1.1.1.1
  date: 1997/11/27 08:33:51;  author: michael;  state: Exp;  lines: +0 -0
  FPC RTL CVS start
  =============================================================================
}
