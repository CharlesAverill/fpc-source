{
    $Id$
    This file is part of the Free Pascal run time library.
    Copyright (c) 1993,97 by the Free Pascal development team.

    See the file COPYING.FPC, included in this distribution,
    for details about the copyright.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

 **********************************************************************}

 { internal put pixel with colour in internal format }
procedure putpixeli(x,y:integer;colour:longint);
var viewport:viewporttype;
begin
if aktviewport.clip then viewport:=aktviewport else viewport:=aktscreen;
  asm
      xorl   %eax,%eax
      movl   %eax,%ebx
      movw   x,%bx
      movw   y,%ax
      addw   _AKTVIEWPORT,%bx
      addw   _AKTVIEWPORT+2,%ax
(*      cmpw   viewport,%bx
      jl     p_exit                        // wenn x < x1 Ende
      cmpw   -8(%ebp),%bx
      jg     p_exit                        // wenn x > x2 Ende
      cmpw   -10(%ebp),%ax
      jl     p_exit                        // wenn y < y1 Ende
      cmpw   -6(%ebp),%ax
      jg     p_exit                        // wenn y > y2 Ende
       assumes wrong placement of viewport !!! PM *)
      lea    viewport,%edx
      cmpw   (%edx),%bx
      jl     p_exit                        // wenn x < x1 Ende
      cmpw   4(%edx),%bx
      jg     p_exit                        // wenn x > x2 Ende
      cmpw   2(%edx),%ax
      jl     p_exit                        // wenn y < y1 Ende
      cmpw   6(%edx),%ax
      jg     p_exit                        // wenn y > y2 Ende
      movl   _Y_ARRAY(,%eax,4),%eax
      addl   _X_ARRAY(,%ebx,4),%eax
      movl   %eax,%esi
      movzbl _WINSHIFT,%ecx                // { offset / winsize        }
      shrl   %cl,%eax                      //
      cmpl   _A_BANK,%eax                 // { same bank ?             }
      je     p_dont_switch                 // { yep                     }
      pushl  %esi
      pushl  %eax                          //
      movl   _BANKSWITCHPTR,%eax           // { switchbank              }
      call   %eax                          //
      popl   %esi
  p_dont_switch:
      andl   _WINLOMASK,%esi
      movl   colour,%eax
      addl   _WBUFFER,%esi
      movw   _SEG_WRITE,%bx
      movw   _BYTESPERPIXEL,%cx
      movw   %bx,%gs
      cmpl   $2,%ecx
      je     pp_16BPP
      jb     pp_8BPP
{$ifdef TEST_24BPP}
      cmpl   $3,%ecx
      je     pp_24BPP
  pp_32BPP:
      movl   %eax,%gs:(%esi)
      jmp    pp_exit
  pp_24BPP:
      movl   _WINLOMASKMINUSPIXELSIZE,%edi
      cmpl   %edi,%esi
      ja     pp_exit
      movl   %gs:(%esi),%edi
      andl   $0xFF000000,%edi
      andl   $0x00FFFFFF,%eax
      orl    %edi,%eax
      movl   %eax,%gs:(%esi)
      jmp    pp_exit
{$endif TEST_24BPP}
  pp_8BPP:
      movb   %al,%gs:(%esi)
      jmp    pp_exit
  pp_16BPP:
      movw   %ax,%gs:(%esi)
  pp_exit:
      (* movw   %dx,%ds use %gs now
      does not need to be kept constant PM *)
  p_exit:
  end;
end; { proc }

procedure putpixel(x,y:integer;colour:longint);
begin
  colour:=convert(colour);
  putpixeli(x,y,colour);
end;

procedure pixel(offset:longint);
 { wird nur intern aufgerufen, umrechnung auf Viewport und Range- }
 { checking muessen von aufrufender Routine bereits erledigt sein }
 { Bankswitching wird durchgefuehrt }
 begin
   asm
      movl   offset,%eax
      movl   %eax,%esi
      movzbl _WINSHIFT,%ecx                // { offset / winsize        }
      shrl   %cl,%eax                      //
      cmpl   _A_BANK,%eax                 // { same bank ?             }
      je     dont_switch                   // { yep                     }
      pushl  %esi
      pushl  %eax                          //
      movl   _BANKSWITCHPTR,%eax           // { switchbank              }
      call   %eax                          //
      popl   %esi
 dont_switch:
      movl   _WINLOMASK,%eax
      andl   %eax,%esi
      movl   _AKTCOLOR,%eax
      movzwl _AKTWRITEMODE,%ecx
      movw   _BYTESPERPIXEL,%bx
      addl   _WBUFFER,%esi
      movw   _SEG_WRITE,%dx
      movw   %dx,%gs
      testl  %ecx,%ecx
      jz     dmove
      cmpl   $2,%ebx
      je     dxor16BPP
      jb     dxor8BPP
{$ifdef TEST_24BPP}
      cmpl   $3,%ebx
      je     dxor24BPP
 dxor32BPP:
      movl   %gs:(%esi),%edx
      xorl   %edx,%eax
      movl   %eax,%gs:(%esi)
      jmp    pd_exit
 dxor24BPP:
      movl   _WINLOMASKMINUSPIXELSIZE,%ecx
      cmpl   %ecx,%esi
      ja     pd_exit
      movl   %gs:(%esi),%edx
      andl   $0x00FFFFFF,%eax
      xorl   %edx,%eax
      movl   %eax,%gs:(%esi)
      jmp    pd_exit
{$endif TEST_24BPP}
 dxor8BPP:
      xorb   %al,%gs:(%esi)
      jmp    pd_exit
 dxor16BPP:
      xorw   %ax,%gs:(%esi)
      jmp    pd_exit
 dmove:
      cmpl   $2,%ebx
      je    dmove16BPP
      jb    dmove8BPP
{$ifdef TEST_24BPP}
      cmpl   $3,%ebx
      je     dmove24BPP
 dmove32BPP:
      movl   %eax,%gs:(%esi)
      jmp    pd_exit
 dmove24BPP:
      movl   _WINLOMASKMINUSPIXELSIZE,%ecx
      cmpl   %ecx,%esi
      ja     pd_exit
      movl   %gs:(%esi),%edx
      andl   $0xFF000000,%edx
      andl   $0x00FFFFFF,%eax
      orl    %edx,%eax
      movl   %eax,%gs:(%esi)
      jmp    pd_exit
{$endif TEST_24BPP}
 dmove8BPP:
      movb   %al,%gs:(%esi)
      jmp    pd_exit
 dmove16BPP:
      movw   %ax,%gs:(%esi)
 pd_exit:
   end;
end; { proc }

function getpixeli(x,y:integer):longint;
var viewport:viewporttype;
    col : longint;
begin
if aktviewport.clip then viewport:=aktviewport else viewport:=aktscreen;
  asm
      movswl x,%ebx
      movswl y,%eax
      addw   _AKTVIEWPORT,%bx
      addw   _AKTVIEWPORT+2,%ax
(*      cmpw   viewport,%bx
      jl     gp_exit                        // wenn x < x1 Ende
      cmpw   -8(%ebp),%bx
      jg     gp_exit                        // wenn x > x2 Ende
      cmpw   -10(%ebp),%ax
      jl     gp_exit                        // wenn y < y1 Ende
      cmpw   -6(%ebp),%ax
      jg     gp_exit                        // wenn y > y2 Ende
      same error : viewport is assumed to be at -12
      that depends on alignment settings !! PM *)
      lea    viewport,%edx
      cmpw   (%edx),%bx
      jl     gp_eexit                        // wenn x < x1 Ende
      cmpw   4(%edx),%bx
      jg     gp_eexit                        // wenn x > x2 Ende
      cmpw   2(%edx),%ax
      jl     gp_eexit                        // wenn y < y1 Ende
      cmpw   6(%edx),%ax
      jg     gp_eexit                        // wenn y > y2 Ende
      movl   _Y_ARRAY(,%eax,4),%eax
      addl   _X_ARRAY(,%ebx,4),%eax
      movl   %eax,%esi
      movzbl _WINSHIFT,%ecx                // { offset / winsize        }
      shrl   %cl,%eax                      //
      cmpl   _A_BANK,%eax                  // { same bank ?             }
      je     g_dont_switch                 // { yep                     }
      pushl  %esi                          // { save Offset             }
      pushl  %eax                          //
      movl   _BANKSWITCHPTR,%eax           // { switchbank              }
      call   %eax                          //
      popl   %esi                          // { restore Offset          }
  g_dont_switch:
      movl   _WINLOMASK,%eax
      andl   %eax,%esi
      xorl   %eax,%eax
      movzwl _BYTESPERPIXEL,%edx
      addl   _WBUFFER,%esi
      movw   _SEG_READ,%bx
      movw   %bx,%gs
      cmpl   $2,%edx                       // { 1 or 2 BytesPerPixel ? }
      je     g_16BPP
      jb     g_8BPP
{$ifdef TEST_24BPP}
      cmpl   $3,%edx                       // { 1 or 2 BytesPerPixel ? }
      je     g_24BPP
  g_32BPP:
      movl   %gs:(%esi),%eax
      andl   $0x00FFFFFF,%eax
      jmp    g_Result
  g_24BPP:
      movl   _WINLOMASKMINUSPIXELSIZE,%edi
      cmpl   %edi,%esi
      ja     g_ErrorResult
      movl   %gs:(%esi),%eax
      andl   $0x00FFFFFF,%eax
      jmp    g_Result
  g_ErrorResult:
      movl   $-3,%edi
      addl   _WINLOMASK,%edi
      cmpl   %edi,%esi
      ja     g_nohope
      decl   %esi
      movl   %gs:(%esi),%eax
      shrl   $8,%eax
      jmp    g_Result
  g_nohope:
      movl   $0xABCDEF,%eax
      jmp    g_Result
{$endif TEST_24BPP}
  g_16BPP:
      movzwl %gs:(%esi),%eax
      jmp    g_Result
  g_8BPP:
      movzbl %gs:(%esi),%eax
      jmp    g_Result
  gp_eexit:
      xorl   %eax,%eax
      jmp    gp_exit
  g_Result:
  gp_exit:
      movl   %eax,col
  end;
  getpixeli:=col;
end; { proc getpixeli }

function getpixel(x,y:integer):longint;
begin
    getpixel:=unconvert(getpixeli(x,y));
end; { proc }


{
  $Log$
  Revision 1.1  1998-12-21 13:07:04  peter
    * use -FE

  Revision 1.5  1998/11/20 18:42:09  pierre
    * many bugs related to floodfill and ellipse fixed

  Revision 1.4  1998/11/18 13:23:36  pierre
    * floodfill got into an infinite loop !!
    + added partial support for fillpoly
      (still wrong if the polygon is not convex)
      Simply make a floodfill from the barycenter !
    * some 24BPP code changed (still does not work for my S3VBE program !)

  Revision 1.3  1998/11/18 09:31:40  pierre
    * changed color scheme
      all colors are in RGB format if more than 256 colors
    + added 24 and 32 bits per pixel mode
      (compile with -dDEBUG)
      24 bit mode with banked still as problems on pixels across
      the bank boundary, but works in LinearFrameBufferMode
      Look at install/demo/nmandel.pp

  Revision 1.2  1998/10/22 08:22:06  pierre
   * mandel problem fixed !!

  Revision 1.1.1.1  1998/03/25 11:18:42  root
  * Restored version

  Revision 1.3  1998/01/26 11:58:33  michael
  + Added log at the end



  Working file: rtl/dos/ppi/pixel.ppi
  description:
  ----------------------------
  revision 1.2
  date: 1997/12/01 12:21:32;  author: michael;  state: Exp;  lines: +13 -1
  + added copyright reference in header.
  ----------------------------
  revision 1.1
  date: 1997/11/27 08:33:51;  author: michael;  state: Exp;
  Initial revision
  ----------------------------
  revision 1.1.1.1
  date: 1997/11/27 08:33:51;  author: michael;  state: Exp;  lines: +0 -0
  FPC RTL CVS start
  =============================================================================
}
