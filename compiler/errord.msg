#
#   $Id$
#   This file is part of the Free Pascal Compiler
#   Copyright (c) 1999 by the Free Pascal Development team
#
#   German (alternative) Language File for Free Pascal
#
#   See the file COPYING.FPC, included in this distribution,
#   for details about the copyright.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#
#
# The constants are build in the following order:
# <part>_<type>_<txtidentifier>
#
# <part> is the part of the compiler the message is used
#   asmr_     assembler parsing
#   asmw_     assembler writing/binary writers
#   unit_     unit handling
#   scan_     scanner
#   parser_   parser
#   type_     type checking
#   general_  general info
#   exec_     calls to assembler, linker, binder
#
# <type> the type of the message it should normally used for
#   f_   fatal error
#   e_   error
#   w_   warning
#   n_   note
#   h_   hint
#   i_   info
#   l_   linenumber
#   u_   used
#   t_   tried
#   m_   macro
#   p_   procedure
#   c_   conditional
#   d_   debug message
#   b_   display overloaded procedures
#   x_   executable informations
#

#
# General
#
# BeginOfTeX
% \section{General compiler messages}
% This section gives the compiler messages which are not fatal, but which
% display useful information. The number of such messages can be
% controlled with the various verbosity level \var{-v} switches.
% \begin{description}
general_t_compilername=T_Compiler: $1
% When the \var{-vt} switch is used, this line tells you what compiler
% is used.
general_d_sourceos=D_Compiler OS: $1
% When the \var{-vd} switch is used, this line tells you what the source
% operating system is.
general_i_targetos=I_Target OS: $1
% When the \var{-vd} switch is used, this line tells you what the target
% operating system is.
general_t_exepath=T_Benutze Pfad fÅr ausfuehrbare Datei: $1
% When the \var{-vt} switch is used, this line tells you where the compiler
% looks for it's binaries.
general_t_unitpath=T_Benutze Unit Pfad: $1
% When the \var{-vt} switch is used, this line tells you where the compiler
% looks for compiled units. You can set this path with the \var{-Fu}
general_t_includepath=T_Benutze Include Pfad: $1
% When the \var{-vt} switch is used, this line tells you where the compiler
% looks for it's include files (files used in \var{\{\$I xxx\}} statements).
% You can set this path with the \var{-I} option.
general_t_librarypath=T_Benutze Bibliotheks Pfad: $1
% When the \var{-vt} switch is used, this line tells you where the compiler
% looks for the libraries. You can set this path with the \var{-Fl} option.
general_t_objectpath=T_Benutze Object Pfad: $1
% When the \var{-vt} switch is used, this line tells you where the compiler
% looks for object files you link in (files used in \var{\{\$L xxx\}} statements).
% You can set this path with the \var{-Fo} option.
general_i_abslines_compiled=I_$1 Zeilen compiliert, $2 sec
% When the \var{-vi} switch is used, the compiler reports the number
% of lines compiled, and the time it took to compile them (real time,
% not program time).
general_f_no_memory_left=F_Kein Speicher mehr Åbrig
% The compiler doesn't have enough memory to compile your program. There are
% several remedies for this:
% \begin{itemize}
% \item If you're using the build option of the compiler, try compiling the
% different units manually.
% \item If you're compiling a huge program, split it up in units, and compile
% these separately.
% \item If the previous two don't work, recompile the compiler with a bigger
% heap (you can use the \var{-Ch} option for this, \seeo{Ch})
% \end{itemize}
% \end{description}
#
# Scanner
#
% \section{Scanner messages.}
% This section lists the messages that the scanner emits. The scanner takes
% care of the lexical structure of the pascal file, i.e. it tries to find
% reserved words, strings, etc. It also takes care of directives and
% conditional compiling handling.
% \begin{description}
scan_f_end_of_file=F_Unerwartetes Dateiende
% this typically happens in on of the following cases :
% \begin{itemize}
% \item The source file ends befor then final \var{end.} statement. This
% happens mostly when the \var{begin} and \var{end} statements aren't
% balanced;
% \item An include file ends in the middle of a statement.
% \item A comment wasn't closed.
% \end{itemize}
scan_f_string_exceeds_line=F_Zeichenkette geht Åber Zeilenende hinaus
% You forgot probably to include the closing ' in a string, so it occupies
% multiple lines.
scan_f_illegal_char=F_unzulaessiges Zeichen
% An illegal character was encountered in the input file.
scan_f_syn_expected=F_Syntax Fehler, $1 erwartet aber $2 vorgefunden
% This indicates that the compiler expected a different token than
% the one you typed. It can occur almost everywhere where you make a
% mistake against the pascal language.
scan_t_start_include_file=T_Beginne mit Lesen der Include-Datei $1
% When you provide the \var{-vt} switch, the compiler tells you
% when it starts reading an included file.
scan_w_comment_level=W_Kommentarstufe $1 gefunden
% When the \var{-vw} switch is used, then the compiler warns you if
% it finds nested comments. Nested comments are not allowed in Turbo Pascal
% and can be a possible source of errors.
scan_n_far_directive_ignored=N_$F Direktive (FAR) ignoriert
% The \var{FAR} directive is a 16-bit construction which is recorgnised
% but ignored by the compiler, since it produces 32 bit code.
scan_n_stack_check_global_under_linux=N_StackprÅfung ist Global unter Linux
% Stack checking with the \var{-Cs} switch is ignored under \linux, since
% \linux does this for you. Only displayed when \var{-vn} is used.
scan_n_ignored_switch=N_Compiler Schalter $1 wurde ignoriert
% With \var{-vn} on, the compiler warns if it ignores a switch
scan_w_illegal_switch=W_Compiler Schalter $1 ist ungÅltig
% You included a compiler switch (i.e. \var{\{\$... \}}) which the compiler
% doesn't know.
scan_w_switch_is_global=W_Dieser Compiler Schalter hat globale Auswirkung
% When \var{-vw} is used, the compiler warns if a switch is global.
scan_e_illegal_char_const=E_UngÅltige char Konstantante
% This happens when you specify a character with its ASCII code, as in
% \var{\#96}, but the number is either illegal, or out of range. The range
% is 1-255.
scan_f_cannot_open_input=F_Kann Datei $1 nicht îffnen
% \fpc cannot find the program or unit source file you specified on the
% command line.
scan_f_cannot_open_includefile=F_Kann Include-Datei $1 nicht îffnen
% \fpc cannot find the source file you specified in a \var{\{\$include \}}
% stateent.
scan_e_too_much_endifs=E_Zu viele $ENDIF oder $ELSE Direktiven
% Your \var{\{\$IFDEF ..\}} and {\{\$ENDIF\}} statements aren't balanced.
scan_w_only_pack_records=W_Record Elemente koennen nur im Raster 1,2,4 oder 16 Bytes ausgerichtet werden
% You are specifying the \var{\{\$PACKRECORDS n\} } with an illegal value for
% \var{n}. Only 1,2,4 or 16 are valid in this case.
scan_w_only_pack_enum=W_Aufzeahlungen koennen nur im Raster 1,2 or 4 bytes aufgeteilt werden.
% You are specifying the \var{\{\$PACKENUM n\}} with an illegal value for
% \var{n}. Only 1,2 or 4 are valid in this case.
scan_e_endif_expected=E_$1 erwartet fÅr $2 definiert in Zeile $3
% Your conditional compilation statements are unbalanced.
scan_e_preproc_syntax_error=E_Syntaxfehler im Argument einer $if Direktive
% There is an error in the expression following the \var{\{\$if \}} compiler
% directive.
scan_e_error_in_preproc_expr=E_Syntaxfehler im Context einer $if Direktive
% There is an error in the expression following the \var{\{\$if \}} compiler
% directive.
scan_w_marco_cut_after_255_chars=W_Inhalt des Makros wurde nach der Auswertung von 255 Zeichen abgeschnitten
% The contents of macros canno be longer than 255 characters. This is a
% safety in the compiler, to prevent buffer overflows. This is shown as a
% warning, i.e. when the \var{-vw} switch is used.
scan_e_endif_without_if=E_ENDIF ohne IF(N)DEF
% Your \var{\{\$IFDEF ..\}} and {\{\$ENDIF\}} statements aren't balanced.
scan_f_user_defined=F_Benutzer definiert: $1
% A user defined fatal error occurred. see also the \progref
scan_e_user_defined=E_Benutzer definiert: $1
% A user defined error occurred. see also the \progref
scan_w_user_defined=W_Benutzer definiert: $1
% A user defined warning occurred. see also the \progref
scan_n_user_defined=N_Benutzer definiert: $1
% A user defined note was encountered. see also the \progref
scan_h_user_defined=H_Benutzer definiert: $1
% A user defined hint was encountered. see also the \progref
scan_i_user_defined=I_Benutzer definiert: $1
% User defined information was encountered. see also the \progref
scan_e_keyword_cant_be_a_macro=E_Makro, welches ein SchlÅsselwort definiert, bleibt wirkungslos
% You cannot redefine keywords with macros.
scan_f_macro_buffer_overflow=F_Makro PufferÅberlauf wÑhrend Lesen oder EinfÅgen
% Your macro or it's result  was too long for the compiler.
scan_w_macro_deep_ten=W_Expandirung des Makros Åberschreitet Tiefe von 16.
% When expanding a macro macros have been nested to a level of 16.
% The compiler will expand no further, since this may be a sign that
% recursion is used.
scan_e_wrong_styled_switch=E_Compiler Schalter in (* ... *) Kommentaren sind nicht erlaubt
% Compiler switches should always be between \var{\{ \}} comment delimiters.
scan_d_handling_switch=D_Bearbeite Schalter "$1"
% When you set debugging info on (\var{-vd}) the compiler tells you when it
% is evaluating conditional compile statements.
scan_c_endif_found=C_ENDIF $1 entdeckt
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements.
scan_c_ifdef_found=C_IFDEF $1 entdeckt, $2
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements.
scan_c_ifopt_found=C_IFOPT $1 entdeckt, $2
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements.
scan_c_if_found=C_IF $1 entdeckt, $2
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements.
scan_c_ifndef_found=C_IFNDEF $1 entdeckt, $2
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements.
scan_c_else_found=C_ELSE $1 entdeckt, $2
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements.
scan_c_skipping_until=C_öbergehe bis...
% When you turn on conditional messages(\var{-vc}), the compiler tells you
% where it encounters conditional statements, and whether it is skipping or
% compiling parts.
scan_i_press_enter=I_DrÅcken Sie <return> um fortzusetzen
% When the \var{-vi} switch is used, the compiler stops compilation
% and waits for the \var{Enter} key to be pressed when it encounters
% a \var{\{\$STOP\}} directive.
scan_w_unsupported_switch=W_Nicht unterstÅtzter Schalter $1
% When warings are turned on (\var{-vw}) the compiler warns you about
% unsupported switches. This means that the switch is used in Delphi or
% Turbo Pascal, but not in \fpc
scan_w_illegal_directive=W_UngÅltige Compiler Direktive $1
% When warings are turned on (\var{-vw}) the compiler warns you about
% unrecognised switches. For a list of recognised switches, \progref
scan_t_back_in=T_Wieder zurÅck in $1
% When you use (\var{-vt}) the compiler tells you when it has finished
% reading an include file.
scan_w_unsupported_app_type=W_Nicht unterstÅtzter Anwendungs-Typ: $1
% You get this warning, ff you specify an unknown application type
% with the directive $APPTYPE
scan_w_app_type_not_support=W_$APPTYPE wird nicht vom Ziel OS unterstÅtzt
% The $APPTYPE directive is supported by win32 applications only
scan_w_unsupported_asmmode_specifier=W_Nicht unterstÅtzte Assembler Varainte angegeben $1
% When you specify an assembler mode with the \var{\{\$ASMMODE xxx\}}
% the compiler didn't recognize the mode you specified.
scan_w_no_asm_reader_switch_inside_asm=W_ASM-Leser Schalter ist nicht mîglich innerhalb einer asm Sequenz, $1 wird erst in der naechsten Sequenz wirksam
% It is not possible to switch from one assembler reader to another
% inside an assmebler block. The new reader will be used for next
% assembler statement only.
scan_e_wrong_switch_toggle=E_Parameter fÅr Schalter falsch, verwenden Sie ON/OFF oder +/-
% You need to use ON or OFF or a + or - to toggle the switch
scan_e_resourcefiles_not_supported=E_Resource Dateien werden vom aktuellen Zielsystem nicht unterstÅtzt
% The target you are compiling for doesn't support Resource files. The
% only target which can use resource files is Win32
%
% \end{description}
#
# Parser
#
% \section{Parser messages}
% This section lists all parser messages. The parser takes care of the
% semantics of you language, i.e. it determines if your pascal constructs
% are correct.
% \begin{description}
parser_e_syntax_error=E_Parser - Syntax Fehler
% An error against the Turbo Pascal language was encountered. This happens
% typically when an illegal character is found in the sources file.
parser_w_proc_far_ignored=W_SchlÅsselwort FAR wurde ignoriert
% This is a warning. \var{FAR} is a construct for 8 or 16 bit programs. Since
% the compile generates 32 bit programs, it ignores this directive.
parser_w_proc_near_ignored=W_SchlÅsselwort NEAR wurde ignoriert
% This is a warning. \var{NEAR} is a construct for 8 or 16 bit programs. Since
% the compile generates 32 bit programs, it ignores this directive.
parser_w_proc_register_ignored=W_SchlÅsselwort REGISTER wurde ignoriert
% This is a warning. \var{REGISTER} is ignored by FPC programs for now.
% This is introduced first for Delphi compatibility.
parser_e_no_dll_file_specified=E_Keine DLL-Datei angegeben
% No longer in use.
parser_e_export_name_double=E_Doppelter Name fÅr exportierte Funktion $1
% Exported function names inside a specific DLL must all be different
parser_e_export_ordinal_double=E_Doppelter Index fÅr exportierte Funktion $1
% Exported function names inside a specific DLL must all be different
parser_e_export_invalid_index=E_Ungueltiger Index for exportierte Funktion
% DLL function index must be in the range 1..$FFFF
parser_e_constructorname_must_be_init=E_Constructor Name muss INIT sein
% You are declaring a constructor with a name which isn't \var{init}, and the
% \var{-Ss} switch is in effect. See the \var{-Ss} switch (\seeo{Ss}).
parser_e_destructorname_must_be_done=E_Destructor Name muss DONE sein
% You are declaring a constructor with a name which isn't \var{done}, and the
% \var{-Ss} switch is in effect. See the \var{-Ss} switch (\seeo{Ss}).
parser_e_illegal_open_parameter=E_UngÅltiger Open-Parameter
% You are trying to use the wrong type for an open parameter.
parser_e_proc_inline_not_supported=E_SchlÅsselwort INLINE nicht unterstÅtzt
% You tried to compile a program with C++ style inlining, and forgot to
% specify the \var{-Si} option (\seeo{Si}). The compiler doesn't support C++
% styled inlining by default.
parser_w_priv_meth_not_virtual=W_Private Methoden dÅrfen nicht VIRTUAL sein
% You declared a method in the private part of a object (class) as
% \var{virtual}. This is not allowed. Private methods cannot be overridden
% anyway.
parser_w_constructor_should_be_public=W_Constructor muss PUBLIC sein
% Constructors must be in the 'public' part of an object (class) declaration.
parser_w_destructor_should_be_public=W_Destructor muss PUBLIC sein
% Destructors must be in the 'public' part of an object (class) declaration.
parser_n_only_one_destructor=N_Klasse darf nur einen Destructur besitzen
% You can declare only one destructor for a class.
parser_e_no_local_objects=E_Locale Klassen Definitionen sind nicht zulÑssig
% Classes must be defined globally. They cannot be defined inside a
% procedure or function
parser_f_no_anonym_objects=F_Anonyme Klassen Definitionen sind nicht zulÑssig
% An invalid object (class) declaration was encountered, i.e. an
% object or class without methods that isn't derived from another object or
% class. For example:
% \begin{verbatim}
% Type o = object
%          a : longint;
%          end;
% \end{verbatim}
% will trigger this error.
parser_object_has_no_vmt=E_Das Objekt $1 hat keine VMT
parser_e_illegal_parameter_list=E_UngÅltige Parameter List
% You are calling a function with parameters that are of a different type than
% the declared parameters of the function.
parser_e_wrong_parameter_type=E_Falscher Parametertyp angegeben fÅr Argument #$1
% There is an error in the parameter list of the function or procedure.
% The compiler cannot determine the error more accurate than this.
parser_e_wrong_parameter_size=E_Falsche Parameterzahl angegeben
% There is an error in the parameter list of the function or procedure,
% the number of parameters is not correct.
parser_e_overloaded_no_procedure=E_Bezeichner $1 ist keine Funktion, overload nicht mîglich
% The compiler encountered a symbol with the same name as an overloaded
% function, but it isn't a function it can overload.
parser_e_overloaded_have_same_parameters=E_Overload Funktion darf nicht die selbe Parameterliste aufweisen
% You're declaring overloaded functions, but with the same parameter list.
% Overloaded function must have at least 1 different parameter in their
% declaration.
parser_e_header_dont_match_forward=E_Funktionskopf ist nicht identisch mit forward Declaration $1
% You declared a function with same parameters but
% different result type or function specifiers.
parser_e_header_different_var_names=E_Funktionskopf $1 passt nicht zur forward Deklaration: var Name verÑndert $2 => $3
% You declared the function in the \var{interface} part, or with the
% \var{forward} directive, but define it with a different parameter list.
parser_n_duplicate_enum=N_Werte in AufzÑhlungen mÅssen aufsteigend sein
% \fpc allows enumeration constructions as in C. Given the following
% declaration two declarations:
% \begin{verbatim}
% type a = (A_A,A_B,A_E:=6,A_UAS:=200);
% type a = (A_A,A_B,A_E:=6,A_UAS:=4);
% \end{verbatim}
% The second declaration would produce an error. \var{A\_UAS} needs to have a
% value higher than \var{A\_E}, i.e. at least 7.
parser_n_interface_name_diff_implementation_name=N_Namen in Interface und Implementation sind verschieden!
% This note warns you if the implementation and interface names of a
% functions are different, but they have the same mangled name. This
% is important when using overloaded functions (but should produce no error).
parser_e_no_with_for_variable_in_other_segments=E_With kann nicht auf Variablen in anderen Segmenten angewendet werden
% With stores a variable locally on the stack,
% but this is not possible if the variable belongs to another segment.
parser_e_too_much_lexlevel=E_Funktions Verschachtelung > 31
% You can nest function definitions only 31 times.
parser_e_range_check_error=E_BerichsprÅfungsfehler bei Konstantenbestimmung
% The constants are out of their allowed range.
parser_w_range_check_error=W_BerichsprÅfungsfehler bei Konstantenbestimmung
% The constants are out of their allowed range.
parser_e_double_caselabel=E_doppelter case Wert
% You are specifying the same label 2 times in a \var{case} statement.
parser_e_case_lower_less_than_upper_bound=E_Obere Grenze der case Bereichsangabe ist kleiner als untere Grenze
% The upper bound of a \var{case} label is less than the lower bound and this
% is useless
parser_e_type_const_not_possible=E_Klassen sind als typisierte Konstanten nicht zulÑssig
% You cannot declare a constant of type class or object.
parser_e_no_overloaded_procvars=E_Funktions Variablen von overload Funktionen sind nicht zulÑssig
% You are trying to assign an overloaded function to a procedural variable.
% This isn't allowed.
parser_e_invalid_string_size=E_StringlÑnge muss ein Wert zwischen 1 und 255 sein
% The length of a string in Pascal is limited to 255 characters. You are
% trying to declare a string with length lower than 1 or greater than 255
% (This is not true for \var{Longstrings} and \var{AnsiStrings}.
parser_w_use_extended_syntax_for_objects=W_Benutzen Sie die erweiterte Syntax von NEW und DISPOSE fÅr Objekt-Instanzen
% If you have a pointer \var{a} to a class type, then the statement
% \var{new(a)} will not initialize the class (i.e. the constructor isn't
% called), although space will be allocated. you should issue the
% \var{new(a,init)} statement. This will allocate space, and call the
% constructor of the class.
parser_w_no_new_dispose_on_void_pointers=W_Verwendung von NEW oder DISPOSE mit untypisierten Pointern ist ohne Aussage
parser_e_no_new_dispose_on_void_pointers=E_Verwendung von NEW oder DISPOSE mit untypisierten Pointern ist nicht mîglich
% You cannot use \var{new(p)} or \var{dispose(p)} if \var{p} is an untyped pointer
% because no size is associated to an untyped pointer.
% Accepted for compatibility in \var{tp} and \vat{delphi} modes.
parser_e_class_id_expected=E_Klassen-bezeichner erwartet
% This happens when the compiler scans a procedure declaration that contains
% a dot,
% i.e., a object or class method, but the type in front of the dot is not
% a known type.
parser_e_no_type_not_allowed_here=E_Typ Bezeichner ist hier nicht zulÑssig
% You cannot use a type inside an expression.
parser_e_methode_id_expected=E_Methoden Bezeichner erwartet
% This identifier is not a method.
% This happens when the compiler scans a procedure declaration that contains
% a dot, i.e., a object or class method, but the procedure name is not a
% procedure of this type.
parser_e_header_dont_match_any_member=E_Funktioskopf passt zu keiner Methode der Klasse
% This identifier is not a method.
% This happens when the compiler scans a procedure declaration that contains
% a dot, i.e., a object or class method, but the procedure name is not a
% procedure of this type.
parser_p_procedure_start=P_Prozedur/Funktion $1
% When using the \var{-vp} switch, the compiler tells you when it starts
% processing a procedure or function implementation.
parser_e_error_in_real=E_UngÅltige Fliesskomma Konstante
% The compiler expects a floating point expression, and gets something else.
parser_e_fail_only_in_constructor=E_FAIL darf nut in Constructoren verwendet werden
% You are using the \var{FAIL} instruction outside a constructor method.
parser_e_no_paras_for_destructor=E_Destructors kînnen keine Parameter haben
% You are declaring a destructor with a parameter list. Destructor methods
% cannot have parameters.
parser_e_only_class_methods_via_class_ref=E_Nur Klassen-Methoden kînnen Åber den Klassen-Namen angesprochen werden
% This error occurs in a situation like the following:
% \begin{verbatim}
% Type :
%    Tclass = Class of Tobject;
%
% Var C : TClass;
%
% begin
% ...
% C.free
% \end{verbatim}
% \var{Free} is not a class method and hence cannot be called with a class
% reference.
parser_e_only_class_methods=E_Nur Klassen-Methoden kînnen in eine Klassen-Methoden angesprochen werden
% This is related to the previous error. You cannot call a method of an object
% from a inside a class method. The following code would produce this error:
% \begin{verbatim}
% class procedure tobject.x;
%
% begin
%   free
% \end{verbatim}
% Because free is a normal method of a class it cannot be called from a class
% method.
parser_e_case_mismatch=E_Konstante und CASE Typ passen nicht zueinander
% One of the labels is not of the same type as the case variable.
parser_e_illegal_symbol_exported=E_Das Symbol kann nicht aus einer Bibliothek exportiert werden
% You can only export procedures and functions when you write a library. You
% cannot export variables or constants.
parser_w_should_use_override=W_Eine inherit Methode wird verdeckt durch $1
% A method that is declared \var{virtual} in a parent class, should be
% overridden in the descendent class with the \var{override} directive. If you
% don't specify the \var{override} directive, you will hide the parent method;
% you will not override it.
parser_e_nothing_to_be_overridden=E_In der Ahnen Klasse ist keine Methode enthalten mit der override mîglich ist: $1
% You try to \var{override} a virtual method of a parent class that doesn't
% exist.
parser_e_no_procedure_to_access_property=E_Es gibt keine Member-Funktion um auf diese Property zuzugreifen
% You specified no \var{read} directive for a property.
parser_w_stored_not_implemented=W_Die Stored Prorperty Directive ist noch nicht implementiert
% The \var{stored} directive is not yet implemented
parser_e_ill_property_access_sym=E_UngÅltiges Symbol fÅr den Zugriff auf die Property
% There is an error in the \var{read} or \var{write} directives for an array
% property. When you declare an array property, you can only access it with
% procedures and functions. The following code woud cause such an error.
% \begin{verbatim}
% tmyobject = class
%   i : integer;
%   property x [i : integer]: integer read I write i;
% \end{verbatim}
%
parser_e_cant_access_protected_member=E_Kann an dieser Stelle nicht auf das geschÅtzte Feld des Objekts zugreifen
% Fields that are declared in a \var{protected} section of an object or class
% declaration cannot be accessed outside the module wher the object is
% defined, or outside descendent object methods.
parser_e_cant_access_private_member=E_Kann an dieser Stelle nicht auf das private Feld des Objekts zugreifen
% Fields that are declared in a \var{private} section of an object or class
% declaration cannot be accessed outside the module where the class is
% defined.
parser_w_overloaded_are_not_both_virtual=W_Overload Methode einer virtuellen Methode muss auch virtuell sein: $1
% If you declare overloaded methods in a class, then they should either all be
% virtual, or none. You shouldn't mix them.
parser_w_overloaded_are_not_both_non_virtual=W_Overload Methode einer nicht-virtuellen Methode muss auch nicht-virtuell sein: $1
% If you declare overloaded methods in a class, then they should either all be
% virtual, or none. You shouldn't mix them.
parser_e_overloaded_methodes_not_same_ret=E_Overload Methoden die virtuell sind muessen den selben RÅckgabetyp haben: $1
% If you declare virtual overloaded methods in a class definition, they must
% have the same return type.
parser_e_dont_nest_export=E_Mit EXPORT declarierte Funktionen dÅrfen nicht verschachtelt sein
% You cannot declare a function or procedure within a function or procedure
% that was declared as an export procedure.
parser_e_methods_dont_be_export=E_Methoden dÅrfen nicht EXPORTiert werden
% You cannot declare a procedure that is a method for an object as
% \var{export}ed. That is, your methods cannot be called from a C program.
parser_e_call_by_ref_without_typeconv=E_Aufrufe mit VAR Parametern mÅssen exakt stimmen
% When calling a function declared with \var{var} parameters, the variables in
% the function call must be of exactly the same type. There is no automatic
% type conversion.
parser_e_no_super_class=E_Klasse ist keine Eltern-Klasse zur aktuellen Klasse
% When calling inherited methods, you are trying to call a method of a strange
% class. You can only call an inherited method of a parent class.
parser_e_self_not_in_method=E_SELF ist nur in Methoden erlaubt
% You are trying to use the \var{self} parameter outside an object's method.
% Only methods get passed the \var{self} parameters.
parser_e_generic_methods_only_in_methods=E_Methoden dÅrfen nur in anderen Methoden direkt mit dem Klassen-Typbezeichner aufgerufen werden
% A construction like \var{sometype.somemethod} is only allowed in a method.
parser_e_illegal_colon_qualifier=E_UnzulÑssige Verwendung von ':'
% You are using the format \var{:} (colon) 2 times on an expression that
% is not a real expression.
parser_e_illegal_set_expr=E_BerichsprÅfungsfehler in Set Constructor oder doppeltes Set Element
% The declaration of a set contains an error. Either one of the elements is
% outside the range of the set type, either two of the elements are in fact
% the same.
parser_e_pointer_to_class_expected=E_Pointer auf Objekt erwartet
% You specified an illegal type in a \var{New} statement.
% The extended synax of \var{New} needs an  object as a parameter.
parser_e_expr_have_to_be_constructor_call=E_Ausdruck muss ein Constructor-Aufruf sein
% When using the extended syntax of \var{new}, you must specify the constructor
% method of the object you are trying to create. The procedure you specified
% is not a constructor.
parser_e_expr_have_to_be_destructor_call=E_Ausdruck muss ein Destructor-Aufruf sein
% When using the extended syntax of \var{dispose}, you must specify the
% destructor method of the object you are trying to dispose of.
% The procedure you specified is not a destructor.
parser_e_invalid_record_const=E_UnzulÑssige Reihenfolge der Record Elemente
% When declaring a constant record, you specified the fields in the wrong
% order.
parser_e_false_with_expr=E_Typ des Ausdrucks muss eine Klassen oder ein Recordtyp sein
% A \var{with} statement needs an argument that is of the type \var{record}
% or \var{class}. You are using \var{with} on an expression that is not of
% this type.
parser_e_void_function=E_Prozeduren kînnen keinen Wert zurÅckliefern
% In \fpc, you can specify a return value for a function when using
% the \var{exit} statement. This error occurs when you try to do this with a
% procedure. Procedures  cannot return a value.
parser_e_constructors_always_objects=E_Constructoren und Destructoren mÅssen Methoden sein
% You're declaring a procedure as destructor or constructor, when the
% procedure isn't a class method.
parser_e_operator_not_overloaded=E_Operator besitzt kein overload
% You're trying to use an overloaded operator when it isn't overloaded for
% this type.
parser_e_no_reraise_possible=E_Auslîsen einer Exception an dieser stelle nicht mîglich
% You are trying to raise an exception where it isn't allowed. You can only
% raise exceptions in an \var{except} block.
parser_e_no_new_or_dispose_for_classes=E_Die erweiterte Syntax von New oder Dispose ist fÅr Klassen nicht zulÑssig
% You cannot generate an instance of a class with the extended syntax of
% \var{new}. The constructor must be used for that. For the same reason, you
% cannot call \var{Dispose} to de-allocate an instance of a class, the
% destructor must be used for that.
parser_e_asm_incomp_with_function_return=E_Assembler Funktion nicht mîglich mit diesem RÅckgabe Typ
% You're trying to implement a \var{assembler} function, but the return type
% of the function doesn't allow that.
parser_e_procedure_overloading_is_off=E_Prozedur overload ist ausgeschaltet
% When using the \var{-So} switch, procedure overloading is switched off.
% Turbo Pascal does not support function overloading.
parser_e_overload_operator_failed=E_Es ist nicht mîglich overload mit diesem Operator zu machen (bentzen Sie stattdessen '=')
% You are trying to overload an operator which cannot be overloaded.
% The following operators can be overloaded :
% \begin{verbatim}
%    +, -, *, /, =, >, <, <=, >=, is, as, in, **, :=
% \end{verbatim}
parser_e_comparative_operator_return_boolean=E_Vergleichs Operator muss einen boolschen Wert zurÅckgeben
% When overloading the \var{=} operator, the function must return a boolean
% value.
parser_e_only_virtual_methods_abstract=E_Nur virtuelle Methoden kînnen abstrakt sein.
% You are declaring a method as abstract, when it isn't declared to be
% virtual.
parser_f_unsupported_feature=F_Benutzung einer nicht unterstÅtzten Erweiterung!
% You're trying to force the compiler into doing something it cannot do yet.
parser_e_mix_of_classes_and_objects=E_Das Mischen von Klassen und Objekten ist unzulÑssig
% You cannot derive \var{objects} and \var{classes} intertwined . That is,
% a class cannot have an object as parent and vice versa.
parser_w_unknown_proc_directive_ignored=W_Unbekannte Prozedur Direktive wurde ignoriert: $1
% The procedure direcive you secified is unknown. Recognised procedure
% directives are \var{cdecl}, \var{stdcall}, \var{popstack}, \var{pascal}
% \var{register}, \var{export}.
parser_e_absolute_only_one_var=E_absolute kann nur auf eine alleinstehende Variable angewendet werden
% You cannot specify more than one variable before the \var{absolute} directive.
% Thus, the following construct will provide this error:
% \begin{verbatim}
% Var Z : Longint;
%     X,Y : Longint absolute Z;
% \end{verbatim}
% \item [ absolute can only be associated a var or const ]
% The address of a \var{absolute} directive can only point to a variable or
% constant. Therefore, the following code will produce this error:
% \begin{verbatim}
%   Procedure X;
%
%  var p : longint absolute x;
% \end{verbatim}
%
parser_e_absolute_only_to_var_or_const=E_absolute kann nur auf Variablen und Konstanten angewendet werden
% The address of a \var{absolute} directive can only point to a variable or
% constant. Therefore, the following code will produce this error:
% \begin{verbatim}
%   Procedure X;
%
%  var p : longint absolute x;
% \end{verbatim}
%
parser_e_initialized_only_one_var=E_Es kann nur ein Bezeichner initialisert werden
% You cannot specify more than one variable with a initial value
% in Delphi syntax.
parser_e_abstract_no_definition=E_Abtrakte Methoden dÅrfen keine Deklarierung mit Rumpf haben
% Abstract methods can only be declared, you cannot implement them. They
% should be overridden by a descendant class.
parser_e_overloaded_must_be_all_global=E_Diese overload Funktion darf nicht Lokal sein (muss Exportiert werden)
% You are defining a overloaded function in the implementation part of a unit,
% but there is no corresponding declaration in the interface part of the unit.
parser_w_virtual_without_constructor=W_Virtuelle Methoden wurden ohne Constructor verwendet in $1
% If you declare objects or classes that contain virtual methods, you need
% to have a constructor and destructor to initialize them. The compiler
% encountered an object or class with virtual methods that doesn't have
% a constructor/destructor pair.
parser_m_macro_defined=M_Makro definiert: $1
% When \var{-vm} is used, the compiler tells you when it defines macros.
parser_m_macro_undefined=M_Makro gelîscht: $1
% When \var{-vm} is used, the compiler tells you when it undefines macros.
parser_m_macro_set_to=M_Makro $1 auf $2 gesetzt
% When \var{-vm} is used, the compiler tells you what values macros get.
parser_i_compiling=I_Compiliere $1
% When you turn on information messages (\var{-vi}), the compiler tells you
% what units it is recompiling.
parser_d_compiling_second_time=D_Compiliere $1 zum zweiten Mal
% When you request debug messages (\var{-vd}) the compiler tells you what
% units it recompiles for the second time.
parser_e_no_paras_allowed=E_Array Eigenschaften sind an dieser Stelle nicht erlaubt
% You cannot use array properties at that point.
parser_e_no_property_found_to_override=E_Es gibt keine Property fÅr dieses Override
% You want to overrride a property of a parent class, when there is, in fact,
% no such property in the parent class.
parser_e_only_one_default_property=E_Nur eine default Property ist erlaubt, vererbte default Property in Klasse $1 gefunden
% You specified a property as \var{Default}, but a parent class already has a
% default property, and a class can have only one default property.
parser_e_property_need_paras=E_Die default Property muss eine Array Property sein
% Only array properties of classes can be made \var{default} properties.
parser_e_constructor_cannot_be_not_virtual=E_Virtuelle Constructoren werden nur im Klassen-Modell unterstÅtzt
% You cannot have virtual constructors in objects. You can only have them
% in classes.
parser_e_no_default_property_available=E_Keine default Property verfÅgbar
% You try to access a default property of a class, but this class (or one of
% it's ancestors) doesn't have a default property.
parser_e_cant_have_published=E_Die Klasse kann keinen published Bereich haben, benutzen Sie den {$M+} Schalter
% If you want a \var{published} section in a class definition, you must
% use the \var{\{\$M+\}} switch, whch turns on generation of type
% information.
parser_e_forward_declaration_must_be_resolved=E_Forward Deklaration der Klasse $1 muss hier aufgelîst werden so dass der Klassen-Vorfahre benutzt wird
% To be able to use an object as an ancestor object, it must be defined
% first. This error occurs in the following situation:
% \begin{verbatim}
%  Type ParentClas = Class;
%       ChildClass = Class(ParentClass)
%         ...
%       end;
% \end{verbatim}
% Where \var{ParentClass} is declared but not defined.
parser_e_no_local_operator=E_Locale Operatoren werden nicht unterstÅtzt
% You cannot overload locally, i.e. inside procedures or function
% definitions.
parser_e_proc_dir_not_allowed_in_interface=E_Prozedur Direktive $1 unzulÑssig im Interface Bereich
% This procedure directive is not allowed in the \var{interface} section of
% a unit. You can only use it in the \var{implementation} section.
parser_e_proc_dir_not_allowed_in_implementation=E_Prozedur Direktive $1 unzulÑssig im Implementation Bereich
% This procedure directive is not defined in the \var{implementation} section of
% a unit. You can only use it in the \var{interface} section.
parser_e_proc_dir_not_allowed_in_procvar=E_Prozedur Direktive $1 unzulÑssig in einer procvar Deklaration
% This procedure directive cannot be part of a procedural of function
% type declaration.
parser_e_function_already_declared_public_forward=E_Funktion ist bereits deklariert als Public/Forward $1
% You will get this error if a function is defined as \var{forward} twice.
% Or it is once in the \var{interface} section, and once as a \var{forward}
% declaration in the \var{implmentation} section.
parser_e_not_external_and_export=E_Kann nicht beide Bezeichner EXPORT und EXTERNAL benutzen
% These two procedure directives are mutually exclusive
parser_e_name_keyword_expected=E_SchlÅsselwort NAME erwartet
% The definition of an external variable needs a \var{name} clause.
parser_w_not_supported_for_inline=W_$1 noch nicht innerhalb von inline Prozeduren/Funktionen unterstÅtzt
% Inline procedures don't support this declaration.
parser_w_inlining_disabled=W_Inlining deaktiviert
% Inlining of procedures is disabled.
parser_i_writing_browser_log=I_Schreibe Browser log $1
% When information messages are on, the compiler warns you when it
% writes the browser log (generated with the \var{\{\$Y+ \}} switch).
parser_h_maybe_deref_caret_missing=H_Mîglicherweise fehlt eine Pointer Dereferenzierung
% The compiler thinks that a pointer may need a dereference.
parser_f_assembler_reader_not_supported=F_Gewaehlter Assembler-Leser nicht unterstÅtzt
% The selected assembler reader (with \var{\{\$ASMMODE xxx\}} is not
% supported. The compiler can be compiled with or without support for a
% particular assembler reader.
parser_e_proc_dir_conflict=E_Prozedur Direktive $1 steht in Konflikt mit anderen Direktiven
% You specified a procedure directive that conflicts with other directives.
% for instance \var{cdecl} and \var{pascal} are mutually exclusive.
parser_e_call_convention_dont_match_forward=E_Aufruf Konvention passt nicht zur Forward Deklaration
% This error happens when you declare a function or procedure with
% e.g. \var{cdecl;} but omit this directive in the implementation, or vice
% versa. The calling convention is part of the function declaration, and
% must be repeated in the function definition.
parser_e_register_calling_not_supported=E_Register Aufruf Konvention (fastcall) nicht unterstÅtzt
% The \var{register} calling convention, i.e., arguments are passed in
% registers instead of on the stack is not supported. Arguments are always
% passed on the stack.
parser_e_property_cant_have_a_default_value=E_Property kann keinen Vorgabewert haben
% Set properties or indexed properties cannot have a default value.
parser_e_property_default_value_must_const=E_Der Vorgabewert einer Property muss eine Konstante sein
% The value of a \var{default} declared property must be knwon at compile
% time. The value you specified is only known at run time. This happens
% .e.g. if you specify a variable name as a default value.
parser_e_cant_publish_that=E_Symbol darf nicht published sein, nur nur eine Klasse sein
% Only class type variables can be in a \var{published} section of a class
% if they are not declared as a property.
parser_e_cant_publish_that_property=E_Diese Sorte Property knann nicht Published sein
% Properties in a \var{published} section cannot be array properties.
% they must be moved to public sections. Properties in a \var{published}
% section must be an ordinal type, a real type, strings or sets.
parser_w_empty_import_name=W_Leerer Importname angegeben
% Both index and name for the import are 0 or empty
parser_e_empty_import_name=W_Leerer Importname angegeben
% Some targets need a name for the imported procedure or a cdecl specifier
parser_e_used_proc_name_changed=E_Funktions interner name wurde nach der Verwendung einer Funktion gÑndert
parser_e_division_by_zero=E_Division durch Null
% There is a divsion by zero encounted
parser_e_invalid_float_operation=E_UngÅltige Fliesskomma Operation
% An operation on two real type values produced an overflow or a division
% by zero.
parser_e_array_lower_less_than_upper_bound=E_Obere Grenze des Bereichs ist kleinerals die untere Grenze
% The upper bound of a \var{case} label is less than the lower bound and this
% is not possible
parser_e_string_larger_array=E_StringlÑnge ist grîsser als die LÑnge des "array of char"
% The size of the constant string is larger than the size you specified in
% the array[x..y] of char definition
parser_e_ill_msg_expr=E_UngÅltiger Ausdruck nach der Message Direktive
% \fpc supports only integer or string values as message constants
parser_e_ill_msg_param=E_Message Handler akzeptieren nur einen "Call by Reference" Parameter
% A method declared with the \var{message}-directive as message handler
% can take only one parameter which must be declared as call by reference
% Parameters are declared as call by reference using the \var{var}-directive
parser_e_duplicate_message_label=E_Doppeltes Message Label: %1
% A label for a message is used twice in one object/class
parser_e_self_in_non_message_handler=E_Self darf nur in Message Handlern ein expliziter Parameter sein
% The self parameter can be passed only explicit if it is a method which
% is declared as message method handler
parser_e_threadvars_only_sg=E_Threadvariablen kînnen nur statisch oder global sein
% Threadvars must be static or global, you can't declare a thread
% local to a procedure. Local variables are always local to a thread,
% because every thread has it's own stack and local variables
% are stored on the stack
parser_f_direct_assembler_not_allowed=F_Direct Assembler wird als binÑres Ausgabeformat nicht unterstÅtzt
% You can't use direct assembler when using a binary writer, choose an
% other outputformat or use an other assembler reader
parser_w_no_objpas_use_mode=W_Laden sie die OBJPAS Unit nicht manuell, benutzen Sie statdessen {$mode objfpc} oder {$mode delphi}
% You're trying to load the ObjPas unit manual from a uses clause. This is
% not a good idea to do, you can better use the {$mode objfpc} or {$mode delphi}
% directives which load the unit automaticly
parser_e_no_object_override=E_OVERRIDE darf in Objekten nicht verwendet werden
% Override isn't support for objects, use VIRTUAL instead to override
% a method of an anchestor object
% \end{description}
#
# Type Checking
#
% \section{Type checking errors}
% This section lists all errors that can occur when type checking is
% performed.
% \begin{description}
type_e_mismatch=E_Typ passt nicht
% This can happen in many cases:
% \begin{itemize}
% \item The variable you're assigning to is of a different type than the
% expression in the assignment.
% \item You are calling a function or procedure with parameters that are
% incompatible with the parameters in the function or procedure definition.
% \end{itemize}
type_e_incompatible_types=E_Inkompatible Typen: erhalten $1 erwartet $2
% There is no conversion possible between the two types
type_e_integer_expr_expected=E_Integer Ausdruck erwartet
% The compiler expects an expression of type integer, but gets a different
% type.
type_e_ordinal_expr_expected=E_Ganzahliger Ausdruck erwartet
% The expression must be of ordinal type, i.e., maximum a \var{Longint}.
% This happens, for instance, when you specify a second argument
% to \var{Inc} or \var{Dec} that doesn't evaluate to an ordinal value.
type_e_type_id_expected=E_Typ Bezeichner erwartet
% The identifier is not a type, or you forgot to supply a type identifier.
type_e_variable_id_expected=E_Variablen Bezeichner erwartet
% This happens when you pass a constant to a \var{Inc} var or \var{Dec}
% procedure. You can only pass variables as arguments to these functions.
type_e_pointer_type_expected=E_Pointer Typ erwartet
% The variable or expression isn't of the type \var{pointer}. This
% happens when you pass a variable that isn't a pointer to \var{New}
% or \var{Dispose}.
type_e_class_type_expected=E_Klassen Typ erwartet
% The variable of expression isn't of the type \var{class}. This happens
% typically when
% \begin{enumerate}
% \item The parent class in a class declaration isn't a class.
% \item An exception handler (\var{On}) contains a type identifier that
% isn't a class.
% \end{enumerate}
type_e_varid_or_typeid_expected=E_Variable oder Typ Bezeichner erwartet
% The argument to the \var{High} or \var{Low} function is not a variable
% nor a type identifier.
type_e_cant_eval_constant_expr=E_Kann konstanten Ausdruck nicht bestimmen
% No longer in use.
type_e_set_element_are_not_comp=E_Set Elemente sind nicht Kompatibel
% You are trying to make an operation on two sets, when the set element types
% are not the same. The base type of a set must be the same when taking the
% union
type_e_set_operation_unknown=E_Operation fÅr Sets nicht implementiert
% several binary operations are not defined for sets
% like div mod ** (also >= <= for now)
type_w_convert_real_2_comp=W_Automatische Typumwandlung von Fliesskommatyp nach COMP (=integer mit 64 bit)
% An implicit type conversion from a real type to a \var{comp} is
% encountered. Since \var{Comp} is a 64 bit integer type, this may indicate
% an error.
type_h_use_div_for_int=H_Verwenden sie DIV um ein Integer Ergebnis zu erhalten
% When hints are on, then an integer division with the '/' operator will
% procuce this message, because the result will then be of type real
type_e_strict_var_string_violation=E_String Typ ist unpassen, da in $V+ Mode
% When compiling in \var{\{\$V+ \}} mode, the string you pass as a parameter
% should be of the exact same type as the declared parameter of the procedure.
type_e_succ_and_pred_enums_with_assign_not_possible=E_Succ oder Pred kann nicht auf Enums mit Zuweisungen angewendet werden
% When you declared an enumeration type which has assignments in it, as in C,
% like in the following:
% \begin{verbatim}
%   Tenum = (a,b,e:=5);
% \end{verbatim}
% you cannot use the \var{Succ} or \var{Pred} functions on them.
type_e_cant_read_write_type=E_Kann Variablen dieses Typs weder lesen noch schreiben
% You are trying to \var{read} or \var{write} a variable from or to a
% file of type text, which doesn't support that. Only integer types,
% booleans, reals, pchars and strings can be read from/written to a text file.
type_e_typeconflict_in_set=E_Typkonflikt zwischen den Elementen des Sets
% There is at least one set element which is of the wrong type, i.e. not of
% the set type.
type_w_maybe_wrong_hi_lo=W_lo/hi(longint/dword) gibt oberes/unteres Word zurÅck
% \fpc supports an overloaded version of \var{lo/hi} for \var{longint/dword}
% which returns the lower/upper word of the argument. TP always uses
% a 16 bit \var{lo/hi} which returns always bits 0..7 for \var{lo} and the
% bits 8..15 for \var{hi}. If you want the TP behavior you have
% to type case the argument to \var{word/integer}
type_e_integer_or_real_expr_expected=E_Integer oder real Ausdruck erwartet
% The first argument to \var{str} must a real or integer type.
type_e_wrong_type_in_array_constructor=E_Falscher Typ im Array Constructor
% You are trying to use a type in an array constructor which is not
% allowed.
type_e_wrong_parameter_type=E_Inkompatible Typen fÅr Argument #$1: erhalten $2, erwartet $3
% You are trying to pass an invalid type for the specified parameter. 
% \end{description}

#
# Symtable
#
% \section{Symbol handling}
% This section lists all the messages that concern the handling of symbols.
% This means all things that have to do with procedure and variable names.
% \begin{description}
sym_e_id_not_found=E_Bezeichner nicht gefunden $1
% The compiler doesn't know this symbol. Usually happens when you misspel
% the name of a variable or procedure, or when you forgot to declare a
% variable.
sym_f_internal_error_in_symtablestack=F_Interner Fehler in SymTableStack()
% An internal error occurred in the compiler; If you encounter such an error,
% please contact the developers and try to provide  an exact description of
% the circumstances in which the error occurs.
sym_e_duplicate_id=E_Doppelter Bezeichner $1
% The identifier was already declared in the current scope.
sym_h_duplicate_id_where=H_Bezeichner ist bereits definiert in $1 auf Zeile $2
% The identifier was already declared in a previous scope.
sym_e_unknown_id=E_Unbekannter Bezeichner $1
% The identifier encountered hasn't been declared, or is used outside the
% scope where it's defined.
sym_e_forward_not_resolved=E_Forward Deklaration nicht gefunden $1
% This can happen in two cases:
% \begin{itemize}
% \item This happens when you declare a function (in the \var{interface} part, or
% with a \var{forward} directive, but do not implement it.
% \item You reference a type which isn't declared in the current \var{type}
% block.
% \end{itemize}
sym_f_id_already_typed=F_Bezeichner Typ ist bereits als Typ definiert
% You are trying to redefine a type.
sym_e_error_in_type_def=E_Fehler in Typdefinition
% There is an error in your definition of a new array type:
% \item One of the range delimiters in an array declaration is erroneous.
% For example, \var{Array [1..1.25]} will trigger this error.
sym_e_type_id_not_defined=E_Typ Bezeichner nicht definiert
% The type identifier has not been defined yet.
sym_e_forward_type_not_resolved=E_Forward Typ nicht gefunden $1
% The compiler encountered an unknown type.
sym_e_only_static_in_static=E_Nur statische Variablen kînnen in statischen Methoden oder outside Methoden benutzt werden
% A static method of an object can only access static variables.
sym_e_invalid_call_tvarsymmangledname=E_UngÅltiger Aufruf von tvarsym.mangledname()
% An internal error occurred in the compiler; If you encounter such an error,
% please contact the developers and try to provide  an exact description of
% the circumstances in which the error occurs.
sym_f_type_must_be_rec_or_class=F_Record oder Klassen Typ erwartet
% The variable or expression isn't of the type \var{record} or \var{class}.
sym_e_no_instance_of_abstract_object=E_Instanzen von Klassen oder Objecten mit abtsrakten Methoden sind nicht zulÑssig
% You are trying to generate an instance of a class which has an abstract
% method that wasn't overridden.
sym_w_label_not_defined=W_Label nicht Definiert $1
% A label was declared, but not defined.
sym_e_ill_label_decl=E_UngÅltige Label Deklaration
sym_e_goto_and_label_not_supported=E_GOTO und LABEL werden nicht unterstÅtzt (verwenden Sie den Schalter -Sg)
% You must compile a program which has \var{label}s and \var{goto} statements
% with the  \var{-Sg} switch. By default, \var{label} and \var{goto} aren't
% supported.
sym_e_label_not_found=E_Label nicht gefunden
% A \var{goto label} was encountered, but the label isn't declared.
sym_e_id_is_no_label_id=E_Bezeichner ist kein Label
% The identifier specified after the \var{goto} isn't of type label.
sym_e_label_already_defined=E_Label ist bereits definiert
% You are defining a label twice. You can define a label only once.
sym_e_ill_type_decl_set=E_UngÅltige Typ Deklaration von Set Elementen
% The declaration of a set contains an invalid type definition.
sym_e_class_forward_not_resolved=E_Forward Klassen Definition nicht gefunden $1
% You declared a class, but you didn't implement it.
sym_h_para_identifier_not_used=H_Parameter nicht benutzt $1
% This is a warning. The identifier was declared (locally or globally) but
% wasn't used (locally or globally).
sym_n_local_identifier_not_used=N_Locale Variable nicht benutzt $1
% You have declared, but not used a variable in a procedure or function
% implementation.
sym_e_set_expected=E_Set Typ erwartet
% The variable or expression isn't of type \var{set}. This happens in an
% \var{in} statement.
sym_w_function_result_not_set=W_Funktions Ergebnis scheint kein Set zu sein
% You can get this warning if the compiler thinks that a function return
% value is not set. This will not be displayed for assembler procedures,
% or procedures that contain assembler blocks.
sym_e_illegal_field=E_Unbekannter Record Feld Bezeichner $1
% The field doesn't exist in the record definition.
sym_n_uninitialized_local_variable=W_Locale Variable $1 scheint nicht initialisiert zu sein
% This message is displayed if the compiler thinks that a variable will
% be used (i.e. appears in the right-hand-side of an expression) when it
% wasn't initialized first (i.e. appeared in the right-hand side of an
% assigment)
sym_e_id_no_member=E_Bezeichener verweist nicht auf ein Element $1
% When using the extended syntax of \var{new}, you must specify the constructor
% method of the class you are trying to create. The procedure you specified
% does not exist.
sym_b_param_list=B_Deklaration gefunden: $1
% You get this when you use the \var{-vb} switch. In case an overloaded
% procedure is not found, then all candidate overloaded procedures are
% listed, with their parameter lists.
% \end{description}
#
# Codegenerator
#
% \section{Code generator messages}
% This section lists all messages that can be displayed if the code
% generator encounters an error condition.
% \begin{description}
cg_e_break_not_allowed=E_BREAK nicht zulÑssig
% You're trying to use \var{break} outside a loop construction.
cg_e_continue_not_allowed=E_CONTINUE nicht zulÑssig
% You're trying to use \var{continue} outside a loop construction.
cg_e_too_complex_expr=E_Ausdruck zu komplex - FPU StackÅberlauf
% Your expression is too long for the compiler. You should try dividing the
% construct over multiple assignments.
cg_e_illegal_expression=E_UngÅltiger Ausdruck
% This can occur under many circumstances. Mostly when trying to evaluate
% constant expressions.
cg_e_invalid_integer=E_UngÅltiger Ausdruck, kein Integer
% You made an expression which isn't an integer, and the compiler expects the
% result to be an integer.
cg_e_invalid_qualifier=E_UngÅltige Kombination
% One of the following is happening :
% \begin{itemize}
% \item You're trying to access a field of a variable that is not a record.
% \item You're indexing a variable that is not an array.
% \item You're dereferencing a variable that is not a pointer.
% \end{itemize}
cg_e_upper_lower_than_lower=E_Oberes Bereichsende < unteres Bereichsende
% You are declaring a subrange, and the lower limit is higher than the high
% limit of the range.
cg_e_illegal_count_var=E_UnzulÑssige ZÑhlvariable
% The type of a \var{for} loop variable must be an ordinal type.
% Loop variables cannot be reals or strings.
cg_e_cant_choose_overload_function=E_Kann nicht eindeutig einer bestimmten overload Funktion zuordnen
% You're calling overloaded functions with a parameter that doesn't correspond
% to any of the declared function parameter lists. e.g. when you have declared
% a function with parameters \var{word} and \var{longint}, and then you call
% it with a parameter which is of type \var{integer}.
cg_e_parasize_too_big=E_Grîsse der Parameterliste Åbersteigt 65535 Bytes
% The I386 processor limits the parameter list to 65535 bytes (the \var{RET}
% instruction causes this)
cg_e_illegal_type_conversion=E_UnzulÑssige Typumwandlung
% When doing a type-cast, you must take care that the sizes of the variable and
% the destination type are the same.
cg_e_file_must_call_by_reference=E_Filetypen mÅssen VAR Parameter sein
% You cannot specify files as value parameters, i.e. they must always be
% declared \var{var} parameters.
cg_e_cant_use_far_pointer_there=E_Die Verwendung eines FAR Pointers ist in dieser Art nicht erlaubt
% Free Pascal doesn't support far pointers, so you cannot take the address of
% an expression which has a far reference as a result. The \var{mem} construct
% has a far reference as a result, so the following code will produce this
% error:
% \begin{verbatim}
% var p : pointer;
% ...
% p:=@mem[a000:000];
% \end{verbatim}
cg_e_var_must_be_reference=E_UnzulÑssiger "call by reference" Parameter
% You are trying to pass a constant or an expression to a procedure that
% requires a \var{var} parameter. Only variables can be passed as a \var{var}
% parameter.
cg_e_dont_call_exported_direct=E_Mit EXPORT deklarierte Funktionen kînnen nicht aufgerufen werden
% No longer in use.
cg_w_member_cd_call_from_method=W_Mîglicherweise unzulÑssiger Aufruf eines Constructors oder Destructors (passt nicht in diesen Kontext)
% No longer in use.
cg_n_inefficient_code=N_Uneffiziente Programmierung
% You construction seems dubious to the compiler.
cg_w_unreachable_code=W_Code wird niemals ausgefÅhrt
% You specified a loop which will never be executed. Example:
% \begin{verbatim}
% while false do
%   begin
%   {.. code ...}
%   end;
% \end{verbatim}
cg_e_stackframe_with_esp=E_Prozedur Aufruf mit Stackframe ESP/SP
% The compiler enocountered a procedure or function call inside a
% procedure that uses a \var{ESP/SP} stackframe. Normally, when a call is
% done the procedure needs a \var{EBP} stackframe.
cg_e_cant_call_abstract_method=E_Abstrakte Methoden kînnen nicht direkt aufgerufen werden
% You cannot call an abstract method directy, instead you must call a
% overriding child method, because an abstract method isn't implemented.
cg_f_internal_error_in_getfloatreg=F_Interner Fehler in getfloatreg(), Allozierungsfehler
% An internal error occurred in the compiler; If you encounter such an error,
% please contact the developers and try to provide  an exact description of
% the circumstances in which the error occurs.
cg_f_unknown_float_type=F_Unbekannter Fliesskomma Typ
% The compiler cannot determine the kind of float that occurs in an expression.
cg_f_secondvecn_base_defined_twice=F_SecondVecn() Basis wurde zweimal definiert
% An internal error occurred in the compiler; If you encounter such an error,
% please contact the developers and try to provide  an exact description of
% the circumstances in which the error occurs.
cg_f_extended_cg68k_not_supported=F_Extended wird auf der m68k Platform nicht unterstÅtzt
% The var{extended} type is not supported on the m68k platform.
cg_f_32bit_not_supported_in_68000=F_vorzeichenlose 32-bit Typen werden im MC68000 Modus nicht unterstÅzt
% The cardinal/dword is not supported on the m68k platform.
cg_f_internal_error_in_secondinline=F_Interner Fehler in secondinline()
% An internal error occurred in the compiler; If you encounter such an error,
% please contact the developers and try to provide  an exact description of
% the circumstances in which the error occurs.
cg_d_register_weight=D_Register $1 Gewichtung $2 $3
% Debugging message. Shown when the compiler considers a variable for
% keeping in the registers.
cg_e_stacklimit_in_local_routine=E_Stacklimit in  lokaler Routine Åberschritten
% Your code requires a too big stack. Some operating systems pose limits
% on the stack size. You should use less variables or try ro put large
% variables on the heap.
cg_d_stackframe_omited=D_Stackframe wird ausgelassen
% Some procedure/functions do not need a complete stack-frame, so it is omitted.
% This message will be displayed when the {-vd} switch is used.
cg_e_unable_inline_object_methods=E_Object Methoden kînnen nicht Inline sein
% You cannot have inlined object methods.
cg_e_unable_inline_procvar=E_Procvar Aufrufe kînnen nicht Inline sein
% A procedure with a procedural variable call cannot be inlined.
cg_e_no_code_for_inline_stored=E_Kein Code fÅr Inline Prozedur gespeichert
% The compiler couldn't store code for the inline procedure.
cg_e_can_access_element_zero=E_Auf Element Null von Ansi/Wide- oder Longstring kann nicht zugegriffen werden, benutzen Sie stattdessen (Set)Length
% You should use \var{setlength} to set the length of an ansi/wide/longstring
% and \var{length} to get the length of such kinf of string
cg_e_include_not_implemented=E_Include und Exclude sind fÅr diesen Fall noch nicht implementiert
% \var{include} and \var{exclude} are only partially
% implemented for \var{i386} processors
% and not at all for \var{m68k} processors.
cg_w_may_wrong_math_argument=W_Mîglicherweise unzulÑssige Konstante wurde an interne Algebra-Funktion Åbergeben
% The constant argument passed to a ln or sqrt function is out of
% the definition range of these functions, you may get unexpected
% results when running the program
cg_e_cannot_call_cons_dest_inside_with=E_Constructoren und Destruktoren kînnen in diesem Kontext nicht aufgerufen wenrden
cg_e_cannot_call_message_direct=E_Kann Message Handler Methode nicht direkt aufrufen
% A message method handler method can't be called directly if it contains an
% explicit self argument
% \end{description}
# EndOfTeX

#
# Assembler reader
#
asmr_d_start_reading=D_Starte $1 Stil Assembler Parsen
asmr_d_finish_reading=D_Beende $1 Stil Assembler Parsen
asmr_e_none_label_contain_at=E_Nicht-Label Bezeichner enthÑlt @
asmr_w_override_op_not_supported=W_Override Operator wird nicht unterstÅtzt
asmr_e_building_record_offset=E_Fehler beim Ermittlen des Recordoffsets
asmr_e_offset_without_identifier=E_OFFSET ohne Bezeicner verwendet
asmr_e_no_local_or_para_allowed=E_Lokale Variable oder Parameter kînnen hier nicht versendet werden
asmr_e_need_offset=E_Hier muss OFFSET verwendet werden
asmr_e_cant_have_multiple_relocatable_symbols=E_Verwendung von mehreren verschiebbraren Symbolen nicht mîglich
asmr_e_only_add_relocatable_symbol=E_Verschiebbares Symbol kann nur addiert werden
asmr_e_invalid_constant_expression=E_UngÅltiger Konstantenausdruck
asmr_e_relocatable_symbol_not_allowed=E_Verschiebbares Symbol ist nicht zulÑssig
asmr_e_invalid_reference_syntax=E_UngÅltige Verweis-Syntax
asmr_e_local_symbol_not_allowed_as_ref=E_Lokale Symbole sind als Referenz nicht zulÑssig
asmr_e_wrong_base_index=E_UngÅltige Verwendung von Basis- und Index-Registern
asmr_e_wrong_scale_factor=E_Falscher Skalierungsfator angegeben
asmr_e_multiple_index=E_Mehrfache Verwendung fon Index-Registern
asmr_e_invalid_operand_type=E_UngÅltiger Operandentyp
asmr_e_invalid_string_as_opcode_operand=E_UngÅlitge Zeichenkette als Opcode Operand: $1
asmr_w_CODE_and_DATA_not_supported=W_@CODE und @DATA werden nicht unterstÅtzt
asmr_e_null_label_ref_not_allowed=E_Null-Label Bezug nicht mîglich
asmr_e_ev_zero_divide=F_Division durch Null in asm Ausdruck
asmr_e_ev_stack_overflow=F_Ausdruck liefert StackÅberlauf
asmr_e_ev_stack_underflow=F_Ausdruck liefert Stackunterlauf
asmr_e_ev_invalid_number=F_UngÅltiges Zahlenformat in asm Ausdruck
asmr_e_ev_invalid_op=F_UngÅltiger Operator in asm Ausdruck
asmr_e_escape_seq_ignored=E_Escape Sequenz Ignoriert: $1
asmr_e_invalid_symbol_ref=E_UngÅltige Symbol Verwendung
asmr_w_fwait_emu_prob=W_Fwait kann Emulationsprobleme mit emu387 verursachen
asmr_w_calling_overload_func=W_Aufruf einer overload Funktion in Assembler
asmr_e_unsupported_symbol_type=E_Nicht unterstÅtzter Symboltyp fÅr Operand
asmr_e_constant_out_of_bounds=E_Konstante ausserhalb des Bereichts
asmr_e_error_converting_decimal=E_Fehler beim Umwandeln in Dezimal $1
asmr_e_error_converting_octal=E_Fehler beim Umwandeln in Oktal $1
asmr_e_error_converting_binary=E_Fehler beim Umwandeln in BinÑr $1
asmr_e_error_converting_hexadecimal=E_Fehler beim Umwandeln in Hexadezimal $1
asmr_h_direct_global_to_mangled=H_$1 Åbersetzt nach $2
asmr_w_direct_global_is_overloaded_func=W_$1 ist einer overload Funktion zugeordnet
asmr_e_cannot_use_SELF_outside_a_method=E_Kann SELF ausserhalb einer Methode nicht verwenden
asmr_e_cannot_use___SELF_outside_methode=E_Kann __SELF ausserhalb einer Methode nicht verwenden
asmr_e_cannot_use___OLDEBP_outside_nested_procedure=E_Kann __OLDEBP ausserhalb einer verschachtelten Prozedur nicht verwednen
asmr_e_void_function=W_Prozeduren kînnen keinen Wert im asm Code zurÅckliefern
asmr_e_SEG_not_supported=E_SEG nicht unterstÅtzt
asmr_e_size_suffix_and_dest_dont_match=E_Grîssensuffix und Ziel- oder Quellgrîsse passen nicht zusammen
asmr_w_size_suffix_and_dest_dont_match=W_Grîssensuffix und Ziel- oder Quellgrîsse passen nicht zusammen
asmr_e_syntax_error=E_Assembler Syntaxfehler
asmr_e_invalid_opcode_and_operand=E_UngÅltige Kombination von Opcode und Operanden
asmr_e_syn_operand=E_Assemler Syntaxfehler im Operanden
asmr_e_syn_constant=E_Assemler Syntaxfehler in Konstanten
asmr_e_invalid_string_expression=E_UngÅltiger String Ausdruck
asmr_w_const32bit_for_address=32bit Konstanten fÅr Adresse erzeugt
asmr_e_invalid_or_missing_opcode=E_UngÅltiger oder fehlender Opcode
asmr_e_invalid_prefix_and_opcode=E_UngÅltige Kombination von Prefix und Opcode: $1
asmr_e_invalid_override_and_opcode=E_UngÅltige Kombination von Override und Opcode: $1
asmr_e_too_many_operands=E_Zu viele Operanden auf der Zeile
asmr_w_near_ignored=W_NEAR ignoriert
asmr_w_far_ignored=W_FAR ignoriert
asmr_e_dup_local_sym=E_Doppelters lokales Symbol $1
asmr_e_unknown_local_sym=E_Undefiniertes lokales Symbol $1
asmr_e_unknown_label_identifier=E_Unbekannter Label Bezeichner $1
asmr_e_invalid_fpu_register=E_UngÅltiger Name fÅr Flieskomma Register
asmr_e_nor_not_supported=E_NOR nicht unterstÅtzt
asmr_w_modulo_not_supported=W_Modulo nicht unterstÅtzt
asmr_e_invalid_float_const=E_UngÅltige Fliesskomma Konstante $1
asmr_e_invalid_float_expr=E_UngÅltiger Fliesskomma Ausdruck
asmr_e_wrong_sym_type=E_Falscher Symboltyp
asmr_e_cannot_index_relative_var=E_Kann lokale Variable oder Parameter nicht mit Register indizieren
asmr_e_invalid_seg_override=E_UngÅltiger Segmentoverride Ausdruck
asmr_w_id_supposed_external=W_Bezeichner $1 ist vermutlich External
asmr_e_string_not_allowed_as_const=E_Strings sind als Konstanten nicht zulÑssig
asmr_e_no_var_type_specified=Typ der Variable nicht angegeben
asmr_w_assembler_code_not_returned_to_text=E_Assembler Code kehrt nicht zum Text zurÅck
asmr_e_not_directive_or_local_symbol=E_Keine Directive oder lokales Symbol $1
asmr_w_using_defined_as_local=E_Verwendung eines definierten Namens als lokales Label


#
# Assembler/binary writers
#
asmw_f_too_many_asm_files=F_Zu viele Assembler Dateien
asmw_f_assembler_output_not_supported=F_GewÑhlte Assembler Ausgabe wird nicht unterstÅtzt
asmw_f_comp_not_supported=F_Comp nicht unterstÅtzt
asmw_f_direct_not_supported=F_Direct nicht unterstÅtzt fÅr binÑres Schreiben
asmw_e_alloc_data_only_in_bss=E_Allozieren von Daten ist nur in bss Abschnitten zulÑssig
asmw_f_no_binary_writer_selected=F_Kein BinÑrschreiber ausgewÑhlt
asmw_e_opcode_not_in_table=E_Asm: Opcode $1 ist nicht in Tabelle
asmw_e_invalid_opcode_and_operands=E_Asm: $1 ungÅltige Kombination von Opcode und Operanden
asmw_e_16bit_not_supported=E_Asm: 16 Bit Verweise nicht untertÅtzt
asmw_e_invalid_effective_address=E_Asm: UngÅltige effektive Adresse
asmw_e_immediate_or_reference_expected=E_Asm: Konstanter Ausdruck oder Referenz erwartet
asmw_e_value_exceeds_bounds=E_Asm: $1 Wert Åberschreitet Grenzen $2
asmw_e_short_jmp_out_of_range=E_Asm: "Short jump" ist ausserhalb der Bereichs $1


#
# Executing linker/assembler
#
exec_w_source_os_redefined=W_Quell-Betriebssystem wurde neu definiert
exec_i_assembling_pipe=I_Assembliere (pipe) $1
exec_d_cant_create_asmfile=E_Kann Assembler Datei nicht erzeugen $1
exec_w_assembler_not_found=W_Assembler $1 nicht gefunden, schalte um auf externes Assemblieren
exec_t_using_assembler=T_Benutze Assembler: $1
exec_w_error_while_assembling=W_Fehler wÑhren des Assemblierens, Exitcode $1
exec_w_cant_call_assembler=W_Kann den Assembler nicht aufrufen, Fehler $1 beim Umschalten auf externen Assembler
exec_i_assembling=I_Assembliere $1
exec_w_linker_not_found=W_Linker $1 nicht gefunden, schalte um auf externes Linken
exec_t_using_linker=T_Benutze Linker: $1
exec_w_objfile_not_found=W_Objekt $1 nicht gefunden, Linken kann fehlschlagen !
exec_w_libfile_not_found=W_Bibliothek $1 nicht gefunden, Linken kann fehlschlagen !
exec_w_error_while_linking=W_Fehler wÑhrend des Linkens
exec_w_cant_call_linker=W_Kann Linker nicht aufrufen, schalte um auf externe Linken
exec_i_linking=I_Linke $1
exec_w_binder_not_found=W_Binder nicht gefunden, schalte um auf externes Binden
exec_w_ar_not_found=W_Ar nicht gefunden, schalte um auf externen ar
exec_e_dll_not_supported=E_Dynamische Bibliotheken nicht unterstÅtzt
exec_i_closing_script=I_Schliesse Skript $1
exec_w_res_not_found=W_Resource Compiler nicht gefunden, schalte um auf externen Modus
exec_i_compilingresource=I_Compiliere Resource $1

#
# Executable information
#
execinfo_f_cant_process_executable=F_Kann ausfÅhrbare Datei nicht nachbearbeiten $1
execinfo_f_cant_open_executable=F_Kann ausfÅhrbare Datei nicht îffnen $1
execinfo_x_codesize=X_Grîsse des Codes: $1 Bytes
execinfo_x_initdatasize=X_Grîsse der initialisierten Daten: $1 Bytes
execinfo_x_uninitdatasize=X_Grîsse der nicht initialisierten Daten: $1 Bytes
execinfo_x_stackreserve=X_Stack Bereich "reserved": $1 Bytes
execinfo_x_stackcommit=X_Stack Bereich "commited": $1 Bytes

#
# Unit loading
#
# BeginOfTeX
% \section{Unit loading messages.}
% This section lists all messages that can occur when the compiler is
% loading a unit from disk into memory. Many of these mesages are
% informational messages.
% \begin{description}
unit_t_unitsearch=T_Suche Unit: $1
% When you use the \var{-vt}, the compiler tells you where it tries to find
% unit files.
unit_t_ppu_loading=T_Lade PPU: $1
% When the \var{-vt} switch is used, the compiler tells you
% what units it loads.
unit_u_ppu_name=U_PPU Name: $1
% When you use the \var{-vu} flag, the unit name is shown.
unit_u_ppu_flags=U_PPU Flags: $1
% When you use the \var{-vu} flag, the unit flags are shown.
unit_u_ppu_crc=U_PPU CRC: $1
% When you use the \var{-vu} flag, the unit CRC check is shown.
unit_u_ppu_time=U_PPU Zeit: $1
% When you use the \var{-vu} flag, the unit time is shown.
unit_u_ppu_file_too_short=U_PPU Datei zu kurz
% When you use the \var{-vu} flag, the unit time is shown.
unit_u_ppu_invalid_header=U_PPU UngÅltiger Header (kein PPU am Anfang)
% A unit file contains as the first three bytes the ascii codes of \var{PPU}
unit_u_ppu_invalid_version=U_PPU UngÅltige Version $1
% This unit file was compiled with a different version of the compiler, and
% cannot be read.
unit_u_ppu_invalid_processor=U_PPU ist fÅr einen anderen Prozessor kompiliert
% This unit file was compiled for a different processor type, and
% cannot be read
unit_u_ppu_invalid_target=U_PPU ist fÅr ein anderes Zielsystem kompiliert
% This unit file was compiled for a different processor type, and
% cannot be read
unit_u_ppu_source=U_PPU Quelle: $1
% When you use the \var{-vu} flag, the unit CRC check is shown.
unit_u_ppu_write=U_Schreibe $1
% When you specify the \var{-vu} switch, the compiler will tell you where it
% writes the unit file.
unit_f_ppu_cannot_write=F_Kann PPU-Datei nicht schreiben
% An err
unit_f_ppu_read_error=F_Lese PPU-Datei
% Unexpected end of file
unit_f_ppu_read_unexpected_end=F_Unerwartetes Ende der PPU-Datei
% This means that the unit file was corrupted, and contains invalid
% information. Recompilation will be necessary.
unit_f_ppu_invalid_entry=F_UngÅltiger Eintrag in PPU-Datei: $1
% The unit the compiler is trying to read is corrupted, or generated with a
% newer version of the compiler.
unit_f_ppu_dbx_count_problem=F_PPU Dbx ZÑhler-Problem
% There is an inconsistency in the debugging information of the unit.
unit_e_illegal_unit_name=E_UngÅltiger Unit Name: $1
% The name of the unit doesn't match the file name.
unit_f_too_much_units=F_Zu viele Units
% \fpc has a limit of 1024 units in a program. You can change this behavior
% by changing the \var{maxunits} constant in the \file{files.pas} file of the
% compiler, and recompiling the compiler.
unit_f_circular_unit_reference=F_Gegenseitige Unit Referenz zwischen $1 und $2
% Two units are using each other in the interface part. This is only allowed
% in the \var{implementation} part. At least one unit must contain the other one
% in the \var{implementation} section.
unit_f_cant_compile_unit=F_Kann Unit $1 nicht Åbersetzen, keine Quellen vorhanden
% A unit was found that needs to be recompiled, but no sources are
% available.
unit_w_switch_us_missed=W_öbersetzen der Systemunit erfordert den Schalter -Us
% When recompiling the system unit (it needs special treatment), the
% \var{-Us} must be specified.
unit_f_errors_in_unit=F_Es traten $1 Fehler beim öbersetzen des Moduls auf, halte an
% When the compiler encounters a fatal error or too many errors in a module
% then it stops with this message.
unit_u_load_unit=U_Lade aus $1 ($2) die Unit $3
% When you use the \var{-vu} flag, which unit is loaded from which unit is
% shown.
unit_u_recompile_crc_change=U_öbersetze $1 erneut, PrÅfsumme fÅr $2 hat sich geÑndert
unit_u_recompile_source_found_alone=U_öbersetze $1, nur Quellcode gefunden
% When you use the \var{-vu} flag, these messages tell you why the current
% unit is recompiled.
unit_u_recompile_staticlib_is_older=U_öbersetze unit erneut, statische Biblothek ist Ñlter als PPU-Datei
% When you use the \var{-vu} flag, the compiler warns if the static library
% of the unit are older than the unit file itself.
unit_u_recompile_sharedlib_is_older=U_öbersetze unit erneut, gemeinsame Bibliothek ist Ñlter als PPU-Datei
% When you use the \var{-vu} flag, the compiler warns if the shared library
% of the unit are older than the unit file itself.
unit_u_recompile_obj_and_asm_older=U_öbersetze unit erneut, obj und asm sind Ñlter als PPU-Datei
% When you use the \var{-vu} flag, the compiler warns if the assembler of
% object file of the unit are older than the unit file itself.
unit_u_recompile_obj_older_than_asm=U_öbersetze unit erneut, obj ist Ñlter als asm
% When you use the \var{-vu} flag, the compiler warns if the assembler
% file of the unit is older than the object file of the unit.
unit_u_start_parse_interface=U_Parse Interface Abschnitt von $1
% When you use the \var{-vu} flag, the compiler warns that it starts
% parsing the interface part of the unit
unit_u_start_parse_implementation=U_Parse Implementation Abschnitt von $1
% When you use the \var{-vu} flag, the compiler warns that it starts
% parsing the implementation part of the unit
unit_u_second_load_unit=U_Zweites Laden fÅr Unit $1
% When you use the \var{-vu} flag, the compiler warns that it starts
% recompiling a unit for the second time. This can happend with interdepend
% units.
unit_u_check_time=U_PPU prÅfe Datei $1 Zeit $2
% When you use the \var{-vu} flag, the compiler show the filename and
% date and time of the file which a recompile depends on
% \end{description}
# EndOfTeX
#
#  Options
#
option_usage=$1 [Optionen] <Eingabedatei> [Optionen]
# BeginOfTeX
%
% \section{Command-line handling errors}
% This section lists errors that occur when the compiler is processing the
% command line or handling the configuration files.
% \begin{description}
option_only_one_source_support=W_Nur eine Quelldatei unterstÅtzt
% You can specify only one source file on the command line. The first
% one will be compiled, others will be ignored. This may indicate that
% you forgot a \var{'-'} sign.
option_def_only_for_os2=W_DEF Datei kann nur fÅr OS/2 erzeugt werden
% This option can only be specified when you're compiling for OS/2
option_no_nested_response_file=E_Verschachtelte Response-Dateien werden nicht unterstÅtzt
% you cannot nest response files with the \var {@file} command-line option.
option_no_source_found=F_Kein Name fuer Quelldatei auf der Kommandzeile
% The compiler expects a source file name on the command line.
option_illegal_para=E_UngÅltiger Parameter: $1
% You specified an unknown option.
option_help_pages_para=H_-? zeigt Hilfetext an
% When an unknown option is given, this message is diplayed.
option_too_many_cfg_files=F_Zu viele verschachtelte Konfigurtionsdateien
% You can only nest up to 16 config files.
option_unable_open_file=F_Kann Datei nicht îffnen $1
% The option file cannot be found.
option_reading_further_from=N_Lese weitere Optionen aus $1
% Displayed when you have notes turned on, and the compiler switches
% to another options file.
option_target_is_already_set=W_Zielsystem ist bereits gesetzt: $1
% Displayed if more than one \var{-T} option is specified.
option_no_shared_lib_under_dos=W_Gemeinsame Bibliotheken sind auf der DOS Platform nicht verfÅgbar, gehe zurÅck nach static
% If you specify \var{-CD} for the \dos platform, this message is displayed.
% The compiler supports only static libraries under \dos
option_too_many_ifdef=F_Zu viele IF(N)DEFs
% the \var{\#IF(N)DEF} statements in the options file are not balanced with
% the \var{\#ENDIF} statements.
option_too_many_endif=F_Zu viele ENDIFs
% the \var{\#IF(N)DEF} statements in the options file are not balanced with
% the \var{\#ENDIF} statements.
option_too_less_endif=F_Offene Bedingung am Dateiende
% the \var{\#IF(N)DEF} statements in the options file are not balanced with
% the \var{\#ENDIF} statements.
option_no_debug_support=W_Erzeugung von Debug Information wird von dieser ausfÅhrbaren Datei nicht unterstÅtzt
% It is possible to have a compiler executable that doesn't support
% the generation of debugging info. If you use such an executable with the
% \var{-g} switch, this warning will be displayed.
option_no_debug_support_recompile_fpc=H_Versuchen Sie mit -dGDB erneut zu kompilieren
% It is possible to have a compiler executable that doesn't support
% the generation of debugging info. If you use such an executable with the
% \var{-g} switch, this warning will be displayed.
option_obsolete_switch=W_Sie verwenden den ehemaligen Schalter $1
% this warns you when you use a switch that is not needed/supported anymore.
% It is recommended that you remove the switch to overcome problems in the
% future, when the switch meaning may change.
%
option_obsolete_switch_use_new=W_Sie benutzen den ehemaligen Schalter $1, bitte benutzen Siease $2
% this warns you when you use a switch that is not supported anymore. You
% must now use the second switch instead.
% It is recommended that you change the switch to overcome problems in the
% future, when the switch meaning may change.
# EndOfTeX
#
# Logo (option -l)
#
option_logo_start=Free Pascal Compiler Version $FPCVER [$FPCDATE] fÅr $FPCTARGET
option_logo_end=Copyright (c) 1993-99 by Florian Klaempfl

#
# Info (option -i)
#
option_info_start=Free Pascal Compiler Version $FPCVER
option_info1=<lf>
option_info2=Compiler Datum :     $FPCDATE
option_info3=Compiler Zielsystem: $FPCTARGET
option_info4=<lf>
option_info5=Dieses Programm unterliegt der GNU General Public Licence
option_info6=FÅr weitere Information lesen Sie bitte COPYING.FPC
option_info7=<lf>
option_info8=Senden Sie Fehlerberichte, VorschlÑge usw. bitte an:
option_info_end=                 fpc-devel@vekoll.saturnus.vein.hu

#
# Help pages (option -? and -h)
#
# note: the ordering of the enum numbering doens't matter
#
ol_begin=**0*_nach boolschen Optionen geben Sie + zum Ein- bzw. - zum Ausschalten an
ol001=**1a_lîsche die erzeugte Assembler-Datei nicht
ol002=**2al_liste Quellcode-Zeilen in der Assembler-Datei
ol003=**2ar_liste Register-Belegung/Freigabe-Information in Assembler-Datei
ol004=**2at_liste Temp-Belegung/Freigabe-Information in Assembler-Datei
ol005=**1b_erzeuge Browser-Info
ol006=**2bl_erzeuge Info zu lokalen Symbolen
ol007=**1B_erzeuge alle Module (Build)
ol008=**1C<x>_Optionen fuer Code-Erzeugung:
ol009=3*2CD_erzeuge dynamische Bibliothek
ol010=**2Ch<n>_<n> Bytes Heap (zwischen 1023 und 67107840)
ol011=**2Ci_IO-PrÅfung
ol012=**2Cn_lasse die Stufe Linken weg
ol013=**2Co_prÅfe öberlauf der Integer Operationen
ol014=**2Cr_fÅhre BereichsprÅfung durch
ol015=**2Cs<n>_setze Grîsse des Stacks zu <n>
ol016=**2Ct_fÅhre StackprÅfung durch
ol017=3*2CS_erzeuge statische Bibliothek
ol018=3*2Cx_benutze Smartlinking
ol019=**1d<x>_definiere das Symbol <x>
ol020=*O1D_erzeuge eine DEF Datei
ol021=*O2Dd<x>_setze Beschreibung zu <x>
ol022=*O2Dw_erzeuge PM Anwendung
ol023=**1e<x>_setze Pfad zur ausfÅhrbaren Datei
ol024=**1F<x>_Dateinamen und Pfade:
ol025=**2FD<x>_setze das Verzeichnis fÅr die Compiler Hilfsprogramme
ol026=**2Fe<x>_leite die Fehlerausgabe um nach <x>
ol027=**2FE<x>_setze den Pfad fuer Exe/Unit Dateien auf <x>
ol028=*L2Fg<x>_identisch mit -Fl
ol029=**2Fi<x>_ergÑnze <x> zum Include-Pfad
ol030=**2Fl<x>_ergÑnze <x> zum Bibliotheks-Pfad
ol031=*L2FL<x>_benutze <x> als dynamischen Linker
ol032=**2Fo<x>_ergÑnze <x> zum Object-Pfad
ol033=**2Fr<x>_lade die Fehler-Meldungs Datei <x>
ol034=**2Fu<x>_ergÑnze <x> zum Unit-Pfad
ol035=**2FU<x>_setze den Unit Ausgabe Pfad auf <x>, hat Vorrang vor -FE
ol036=*g1g<x>_erzeuge Debugger Information:
ol037=*g2gg_benutze gsym
ol038=*g2gd_benutze dbx
ol039=*g2gh_benutze Heap Trace Unit
ol040=**1i_zeige alle Information Åber den Compiler
ol041=**2iD_zeige Compiler Datum
ol042=**2iV_zeige Compiler Version
ol043=**2iSO_zeige Compiler OS
ol044=**2iSP_zeige Compiler Processor
ol045=**2iTO_zeige Zielsystem OS
ol046=**2iTP_zeige Zielsystem Processor
ol047=**1I<x>_ergÑnze <x> zum Include-Pfad
ol048=**1k<x>_Åbergebe <x> an den Linker
ol049=**1l_zeige Logo
ol050=**1n_Standard Parameter-Datei ignorieren
ol051=**1o<x>_Ñndere den Namen der erzeugten ausfuehrbaren Datei in <x>
ol052=**1pg_erzeuge Profiler-Code fÅr gprof
ol053=*L1P_benutze Pipes anstelle von temporÑren Assembler Dateien
ol054=**1S<x>_Syntax Optionen:
ol055=**2S2_schalte einige der Delphi 2 Erweiterungen ein
ol056=**2Sc_unterstÅtze spezielle C Operatoren (*=,+=,/= and -=)
ol057=**2Sd_sei Delphi kompatibel
ol058=**2Se_halte Compiler nach dem ersten Fehler an
ol059=**2Sg_erlaube LABEL und GOTO
ol060=**2Sh_benutze ANSI-Strings
ol061=**2Si_benutze C++ artige INLINE
ol062=**2Sm_unterstÅtze Macros wie in C (global)
ol063=**2So_sei TP/BP 7.0 kompatibel
ol064=**2Sp_sei gpc kompatibel
ol065=**2Ss_bestimme dass Constructor Name: "Init" und Destructor: "Done" ist
ol066=**2St_erlaube SchlÅsselwort static in Objekten
ol067=**1s_rufe weder Assembler noch Linker auf (nur mit -a)
ol068=**1u<x>_entferne die Definition fÅr das Symbol <x>
ol069=**1U<x>_Unit Optionen:
ol070=**2Un_prÅfe den Unit Namen nicht
ol071=**2Us_erzeuge eine System Unit
ol072=**1v<x>_sei mitteilsam, <x> ist eine Kombination der folgenden Zeichen:
ol073=**2*_e : zeige Fehler (Standard)     d : zeige Debug Info
ol074=**2*_w : zeige Warnungen             u : zeige Unit Info
ol075=**2*_n : zeige Anmerkungen           t : zeige angesprochene/benutzte Dateien
ol076=**2*_h : zeige Hinweise              m : zeige definierte Macros
ol077=**2*_i : zeige allgemeine Info       p : zeige compilierte Prozeduren
ol078=**2*_l : zeige Zeilennummern         c : zeige conditionals
ol079=**2*_a : zeige alles                 0 : zeige nichts (ausser Fehlern)
ol080=**2*_b : zeige alle Prozedurdekla-   r : Rhide/GCC kompatibler Modus
ol081=**2*_    rationen im Fehlerfall      x : Exe-Datei Info (nur Win32)
ol082=**2*_
ol083=**1X<x>_Optionen fÅr ausfÅhrbare Dateien:
ol084=*L2Xc_linke mit der c library
ol085=**2XD_linke mit den dynamischen Bibliotheken (definiert FPC_LINK_DYNAMIC)
ol086=**2Xs_entferne alle Symbole vom der ausfÅhrbaren Datei
ol087=**2XS_linke mit den statischen Bibliotheken (definiert FPC_LINK_STATIC)
ol088=**0*_Optionen fuer den Prozessor:
ol089=3*1A<x>_Ausgabeformat:
ol090=3*2Ao_coff-Datei mit Hilfe von GNU AS
ol091=3*2Anasmcoff_coff-Datei mit Hilfe von Nasm
ol092=3*2Anasmelf_elf32-Datei (Linux) mit Hilfe von Nasm
ol093=3*2Anasmobj_obj-Datei mit Hilfe von Nasm
ol094=3*2Amasm_obj-Datei mit Hilfe von Masm (Mircosoft)
ol095=3*2Atasm_obj-Datei mit Hilfe von Tasm (Borland)
ol096=3*1R<x>_Assembler-Leser Format:
ol097=3*2Ratt_lies AT&T Assembler Variante
ol098=3*2Rintel_lies Intel Assembler Variante
ol099=3*2Rdirect_kopiere Assembler-Text direkt in die Assembler-Datei
ol100=3*1O<x>_Optimierungen:
ol101=3*2Og_erzeuge kleineren Code
ol102=3*2OG_erzeuge schnelleren Code (standard)
ol103=3*2Or_behalte bestimmte Variablen in Registern (noch BUGGY!!!)
ol104=3*2Ou_aktiviere unsichere Optimierungen (siehe Documentation)
ol105=3*2O1_Stufe 1 Optimierungen (schnelle Optimierungen)
ol106=3*2O2_Stufe 2 Optimierungen (-O1 + langsamere Optimierungen)
ol107=3*2O3_Stufe 3 Optimierungen (gleich wie -O2u)
ol108=3*2Op<x>_Ziel Processor:
ol109=3*3Op1_setze Ziel-Processor auf 386/486
ol110=3*3Op2_setze Ziel-Processor auf Pentium/PentiumMMX (R)
ol111=3*3Op3_setze Ziel-Processor auf PPro/PII/c6x86/K6 (R)
ol112=3*1T<x>_Ziel Betriebssystem
ol113=3*2TGO32V1_Version 1 von DJ Delorie's DOS extender
ol114=3*2TGO32V2_Version 2 von DJ Delorie's DOS extender
ol115=3*2TLINUX_Linux
ol116=3*2TOS2_OS/2 2.x
ol117=3*2TWin32_Windows 32 Bit
ol118=6*1A<x>_Ausgabe Format:
ol119=6*2Ao_Unix o-Datei mit Hilfe von GNU AS
ol120=6*2Agas_GNU Motorola Assembler
ol121=6*2Amit_MIT Syntax (alter GAS)
ol122=6*2Amot_Standard Motorola Assembler
ol123=6*1O<x>_Optimierungen:
ol124=6*2Oa_schalte Optimierer ein
ol125=6*2Og_erzeuge kleineren Code
ol126=6*2OG_erzeuge schnelleren Code (standard)
ol127=6*2Ox_optimiere Maximal (noch BUGGY!!!)
ol128=6*2O2_setze Ziel-Prozessor auf MC68020+
ol129=6*1R<x>_Assembler-Leser Format:
ol130=6*2RMOT_lies Motorola Assembler Variante
ol131=6*1T<x>_Ziel Betriebssystem
ol132=6*2TAMIGA_Commodore Amiga
ol133=6*2TATARI_Atari ST/STe/TT
ol134=6*2TMACOS_Macintosh m68k
ol135=6*2TLINUX_Linux-68k
ol136=**1*_
ol137=**1?_zeigt diese Hilfe an
ol_end=**1h_zeigt diese Hilfe ohne Warten an

#
# The End...
#

